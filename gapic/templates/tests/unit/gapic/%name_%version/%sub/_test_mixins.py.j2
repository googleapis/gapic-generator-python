{% if api.has_operations_mixin and ('grpc' in opts.transport or 'grpc_asyncio' in opts.transport) %}

{% if "DeleteOperation" in api.mixin_api_methods %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_delete_operation_async(transport: str = "grpc_asyncio"):
{% else %}
def test_delete_operation(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = operations_pb2.DeleteOperationRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.delete_operation), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = None
        response = client.delete_operation(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            None
        )
        response = await client.delete_operation(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert response is None
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_delete_operation_field_headers_async():
{% else %}
def test_delete_operation_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = operations_pb2.DeleteOperationRequest()
    request.name = "locations"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.delete_operation), "__call__") as call:
        {% if mode == "" %}
        call.return_value =  None

        client.delete_operation(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            None
        )
        await client.delete_operation(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "name=locations",) in kw["metadata"]
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_delete_operation_from_dict_async():
{% else %}
def test_delete_operation_from_dict():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.delete_operation), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = None

        response = client.delete_operation(
            request={
                "name": "locations",
            }
        )
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            None
        )
        response = await client.delete_operation(
            request={
                "name": "locations",
            }
        )
        {% endif %}
        call.assert_called()
{% endfor %}

{% endif %} {# DeleteOperation #}

{% if "CancelOperation" in api.mixin_api_methods %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_cancel_operation_async(transport: str = "grpc_asyncio"):
{% else %}
def test_cancel_operation(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = operations_pb2.CancelOperationRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.cancel_operation), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = None
        response = client.cancel_operation(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            None
        )
        response = await client.cancel_operation(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert response is None
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_cancel_operation_field_headers_async():
{% else %}
def test_cancel_operation_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = operations_pb2.CancelOperationRequest()
    request.name = "locations"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.cancel_operation), "__call__") as call:
        {% if mode == "" %}
        call.return_value =  None

        client.cancel_operation(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            None
        )
        await client.cancel_operation(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "name=locations",) in kw["metadata"]
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_cancel_operation_from_dict_async():
{% else %}
def test_cancel_operation_from_dict():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.cancel_operation), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = None

        response = client.cancel_operation(
            request={
                "name": "locations",
            }
        )
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            None
        )
        response = await client.cancel_operation(
            request={
                "name": "locations",
            }
        )
        {% endif %}
        call.assert_called()
{% endfor %}
{% endif %} {# CancelOperation #}

{% if "WaitOperation" in api.mixin_api_methods %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_wait_operation(transport: str = "grpc_asyncio"):
{% else %}
def test_wait_operation(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = operations_pb2.WaitOperationRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.wait_operation), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = operations_pb2.Operation()
        response = client.wait_operation(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.Operation()
        )
        response = await client.wait_operation(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, operations_pb2.Operation)
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_wait_operation_field_headers_async():
{% else %}
def test_wait_operation_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = operations_pb2.WaitOperationRequest()
    request.name = "locations"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.wait_operation), "__call__") as call:
        {% if mode == "" %}
        call.return_value = operations_pb2.Operation()

        client.wait_operation(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.Operation()
        )
        await client.wait_operation(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "name=locations",) in kw["metadata"]
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_wait_operation_from_dict_async():
{% else %}
def test_wait_operation_from_dict():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.wait_operation), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = operations_pb2.Operation()

        response = client.wait_operation(
            request={
                "name": "locations",
            }
        )
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.Operation()
        )
        response = await client.wait_operation(
            request={
                "name": "locations",
            }
        )
        {% endif %}
        call.assert_called()
{% endfor %}

{% endif %} {# WaitOperation #}

{% if "GetOperation" in api.mixin_api_methods %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_get_operation_async(transport: str = "grpc_asyncio"):
{% else %}
def test_get_operation(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = operations_pb2.GetOperationRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_operation), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = operations_pb2.Operation()
        response = client.get_operation(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.Operation()
        )
        response = await client.get_operation(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, operations_pb2.Operation)
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_get_operation_field_headers_async():
{% else %}
def test_get_operation_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = operations_pb2.GetOperationRequest()
    request.name = "locations"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_operation), "__call__") as call:
        {% if mode == "" %}
        call.return_value = operations_pb2.Operation()

        client.get_operation(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.Operation()
        )
        await client.get_operation(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "name=locations",) in kw["metadata"]
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_get_operation_from_dict_async():
{% else %}
def test_get_operation_from_dict():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_operation), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = operations_pb2.Operation()

        response = client.get_operation(
            request={
                "name": "locations",
            }
        )
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.Operation()
        )
        response = await client.get_operation(
            request={
                "name": "locations",
            }
        )
        {% endif %}
        call.assert_called()
{% endfor %}

{% endif %} {# GetOperation #}

{% if "ListOperations" in api.mixin_api_methods %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_list_operations_async(transport: str = "grpc_asyncio"):
{% else %}
def test_list_operations(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = operations_pb2.ListOperationsRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.list_operations), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = operations_pb2.ListOperationsResponse()
        response = client.list_operations(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.ListOperationsResponse()
        )
        response = await client.list_operations(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, operations_pb2.ListOperationsResponse)
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_list_operations_field_headers_async():
{% else %}
def test_list_operations_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = operations_pb2.ListOperationsRequest()
    request.name = "locations"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.list_operations), "__call__") as call:
        {% if mode == "" %}
        call.return_value = operations_pb2.ListOperationsResponse()

        client.list_operations(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.ListOperationsResponse()
        )
        await client.list_operations(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "name=locations",) in kw["metadata"]
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_list_operations_from_dict_async():
{% else %}
def test_list_operations_from_dict():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.list_operations), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = operations_pb2.ListOperationsResponse()

        response = client.list_operations(
            request={
                "name": "locations",
            }
        )
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            operations_pb2.ListOperationsResponse()
        )
        response = await client.list_operations(
            request={
                "name": "locations",
            }
        )
        {% endif %}
        call.assert_called()
{% endfor %}

{% endif %} {# ListOperations #}

{% endif %} {# LRO #}

{% if api.has_location_mixin and ('grpc' in opts.transport or 'grpc_asyncio' in opts.transport) %}

{# ListLocation #}

{% if "ListLocations" in api.mixin_api_methods %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_list_locations_async(transport: str = "grpc_asyncio"):
{% else %}
def test_list_locations(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = locations_pb2.ListLocationsRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.list_locations), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = locations_pb2.ListLocationsResponse()
        response = client.list_locations(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            locations_pb2.ListLocationsResponse()
        )
        response = await client.list_locations(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, locations_pb2.ListLocationsResponse)
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_list_locations_field_headers_async():
{% else %}
def test_list_locations_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = locations_pb2.ListLocationsRequest()
    request.name = "locations"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.list_locations), "__call__") as call:
        {% if mode == "" %}
        call.return_value = locations_pb2.ListLocationsResponse()

        client.list_locations(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            locations_pb2.ListLocationsResponse()
        )
        await client.list_locations(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "name=locations",) in kw["metadata"]
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_list_locations_from_dict_async():
{% else %}
def test_list_locations_from_dict():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.list_locations), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = locations_pb2.ListLocationsResponse()

        response = client.list_locations(
            request={
                "name": "locations",
            }
        )
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            locations_pb2.ListLocationsResponse()
        )
        response = await client.list_locations(
            request={
                "name": "locations",
            }
        )
        {% endif %}
        call.assert_called()
{% endfor %}

{% endif %} {# ListLocations #}

{# GetLocation #}

{% if "GetLocation" in api.mixin_api_methods %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_get_location_async(transport: str = "grpc_asyncio"):
{% else %}
def test_get_location(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = locations_pb2.GetLocationRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_location), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = locations_pb2.Location()
        response = client.get_location(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            locations_pb2.Location()
        )
        response = await client.get_location(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, locations_pb2.Location)
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_get_location_field_headers_async():
{% else %}
def test_get_location_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials())
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials()
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = locations_pb2.GetLocationRequest()
    request.name = "locations/abc"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_location), "__call__") as call:
        {% if mode == "" %}
        call.return_value = locations_pb2.Location()

        client.get_location(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            locations_pb2.Location()
        )
        await client.get_location(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "name=locations/abc",) in kw["metadata"]
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_get_location_from_dict_async():
{% else %}
def test_get_location_from_dict():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.list_locations), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = locations_pb2.Location()

        response = client.get_location(
            request={
                "name": "locations/abc",
            }
        )
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            locations_pb2.Location()
        )
        response = await client.get_location(
            request={
                "name": "locations",
            }
        )
        {% endif %}
        call.assert_called()
{% endfor %}

{% endif %} {# GetLocation #}

{% endif %} {# location_mixin #}

{# TODO: Remove after https://github.com/googleapis/gapic-generator-python/pull/1240 is merged. #}
{% if opts.add_iam_methods and ('grpc' in opts.transport or 'grpc_asyncio' in opts.transport) %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_set_iam_policy_async(transport: str = "grpc_asyncio"):
{% else %}
def test_set_iam_policy(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.SetIamPolicyRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.set_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = policy_pb2.Policy(version=774, etag=b"etag_blob",)
        response = client.set_iam_policy(request)
        {% else %}
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            policy_pb2.Policy(version=774, etag=b"etag_blob",)
        )
        response = await client.set_iam_policy(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, policy_pb2.Policy)

    assert response.version == 774

    assert response.etag == b"etag_blob"
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_set_iam_policy_field_headers_async():
{% else %}
def test_set_iam_policy_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.SetIamPolicyRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.set_iam_policy), "__call__") as call:
        {% if mode == "" %}
        call.return_value = policy_pb2.Policy()

        client.set_iam_policy(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(policy_pb2.Policy())

        await client.set_iam_policy(request)
        {% endif %}

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]
{% endfor %}

def test_set_iam_policy_from_dict():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.set_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = policy_pb2.Policy()

        response = client.set_iam_policy(
            request={
                "resource": "resource_value",
                "policy": policy_pb2.Policy(version=774),
            }
        )
        call.assert_called()


@pytest.mark.asyncio
async def test_set_iam_policy_from_dict_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.set_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            policy_pb2.Policy()
        )

        response = await client.set_iam_policy(
            request={
                "resource": "resource_value",
                "policy": policy_pb2.Policy(version=774),
            }
        )
        call.assert_called()


def test_get_iam_policy(transport: str = "grpc"):
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.GetIamPolicyRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = policy_pb2.Policy(version=774, etag=b"etag_blob",)

        response = client.get_iam_policy(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, policy_pb2.Policy)

    assert response.version == 774

    assert response.etag == b"etag_blob"


@pytest.mark.asyncio
async def test_get_iam_policy_async(transport: str = "grpc_asyncio"):
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.GetIamPolicyRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.get_iam_policy), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            policy_pb2.Policy(version=774, etag=b"etag_blob",)
        )

        response = await client.get_iam_policy(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls)
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, policy_pb2.Policy)

    assert response.version == 774

    assert response.etag == b"etag_blob"


def test_get_iam_policy_field_headers():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.GetIamPolicyRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_iam_policy), "__call__") as call:
        call.return_value = policy_pb2.Policy()

        client.get_iam_policy(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]


@pytest.mark.asyncio
async def test_get_iam_policy_field_headers_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.GetIamPolicyRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.get_iam_policy), "__call__"
    ) as call:
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(policy_pb2.Policy())

        await client.get_iam_policy(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls)
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]


def test_get_iam_policy_from_dict():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = policy_pb2.Policy()

        response = client.get_iam_policy(
            request={
                "resource": "resource_value",
                "options": options_pb2.GetPolicyOptions(requested_policy_version=2598),
            }
        )
        call.assert_called()

@pytest.mark.asyncio
async def test_get_iam_policy_from_dict_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            policy_pb2.Policy()
        )

        response = await client.get_iam_policy(
            request={
                "resource": "resource_value",
                "options": options_pb2.GetPolicyOptions(requested_policy_version=2598),
            }
        )
        call.assert_called()


def test_test_iam_permissions(transport: str = "grpc"):
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.TestIamPermissionsRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = iam_policy_pb2.TestIamPermissionsResponse(
            permissions=["permissions_value"],
        )

        response = client.test_iam_permissions(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, iam_policy_pb2.TestIamPermissionsResponse)

    assert response.permissions == ["permissions_value"]


@pytest.mark.asyncio
async def test_test_iam_permissions_async(transport: str = "grpc_asyncio"):
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.TestIamPermissionsRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            iam_policy_pb2.TestIamPermissionsResponse(permissions=["permissions_value"],)
        )

        response = await client.test_iam_permissions(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls)
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, iam_policy_pb2.TestIamPermissionsResponse)

    assert response.permissions == ["permissions_value"]


def test_test_iam_permissions_field_headers():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.TestIamPermissionsRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        call.return_value = iam_policy_pb2.TestIamPermissionsResponse()

        client.test_iam_permissions(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]


@pytest.mark.asyncio
async def test_test_iam_permissions_field_headers_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.TestIamPermissionsRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            iam_policy_pb2.TestIamPermissionsResponse()
        )

        await client.test_iam_permissions(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls)
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]


def test_test_iam_permissions_from_dict():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = iam_policy_pb2.TestIamPermissionsResponse()

        response = client.test_iam_permissions(
            request={
                "resource": "resource_value",
                "permissions": ["permissions_value"],
            }
        )
        call.assert_called()

@pytest.mark.asyncio
async def test_test_iam_permissions_from_dict_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            iam_policy_pb2.TestIamPermissionsResponse()
        )

        response = await client.test_iam_permissions(
            request={
                "resource": "resource_value",
                "permissions": ["permissions_value"],
            }
        )
        call.assert_called()

{% endif %}

{% if (not opts.add_iam_methods and api.has_iam_mixin) and ('grpc' in opts.transport or 'grpc_asyncio' in opts.transport) %}

{% if "SetIamPolicy" in api.mixin_api_methods %}
{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_set_iam_policy_async(transport: str = "grpc_asyncio"):
{% else %}
def test_set_iam_policy(transport: str = "grpc"):
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )
    {% endif %}

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.SetIamPolicyRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.set_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        {% if mode == "" %}
        call.return_value = policy_pb2.Policy(version=774, etag=b"etag_blob",)
        response = client.set_iam_policy(request)
        {% else %}
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            policy_pb2.Policy(version=774, etag=b"etag_blob",)
        )
        response = await client.set_iam_policy(request)
        {% endif %}
        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, policy_pb2.Policy)

    assert response.version == 774

    assert response.etag == b"etag_blob"
{% endfor %}

{% for mode in ["", "async"] %}
{% if mode == "async" %}
@pytest.mark.asyncio
async def test_set_iam_policy_field_headers_async():
{% else %}
def test_set_iam_policy_field_headers():
{% endif %}
    {% if mode == "" %}
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    {% else %}
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    {% endif %}

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.SetIamPolicyRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.set_iam_policy), "__call__") as call:
        {% if mode == "" %}
        call.return_value = policy_pb2.Policy()

        client.set_iam_policy(request)
        {% else %}
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(policy_pb2.Policy())

        await client.set_iam_policy(request)
        {% endif %}

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]
{% endfor %}

def test_set_iam_policy_from_dict():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.set_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = policy_pb2.Policy()

        response = client.set_iam_policy(
            request={
                "resource": "resource_value",
                "policy": policy_pb2.Policy(version=774),
            }
        )
        call.assert_called()


@pytest.mark.asyncio
async def test_set_iam_policy_from_dict_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.set_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            policy_pb2.Policy()
        )

        response = await client.set_iam_policy(
            request={
                "resource": "resource_value",
                "policy": policy_pb2.Policy(version=774),
            }
        )
        call.assert_called()
{% endif %}

{% if "GetIamPolicy" in api.mixin_api_methods %}
def test_get_iam_policy(transport: str = "grpc"):
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.GetIamPolicyRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = policy_pb2.Policy(version=774, etag=b"etag_blob",)

        response = client.get_iam_policy(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, policy_pb2.Policy)

    assert response.version == 774

    assert response.etag == b"etag_blob"


@pytest.mark.asyncio
async def test_get_iam_policy_async(transport: str = "grpc_asyncio"):
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.GetIamPolicyRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.get_iam_policy), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            policy_pb2.Policy(version=774, etag=b"etag_blob",)
        )

        response = await client.get_iam_policy(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls)
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, policy_pb2.Policy)

    assert response.version == 774

    assert response.etag == b"etag_blob"


def test_get_iam_policy_field_headers():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.GetIamPolicyRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_iam_policy), "__call__") as call:
        call.return_value = policy_pb2.Policy()

        client.get_iam_policy(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]


@pytest.mark.asyncio
async def test_get_iam_policy_field_headers_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.GetIamPolicyRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.get_iam_policy), "__call__"
    ) as call:
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(policy_pb2.Policy())

        await client.get_iam_policy(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls)
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]


def test_get_iam_policy_from_dict():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = policy_pb2.Policy()

        response = client.get_iam_policy(
            request={
                "resource": "resource_value",
                "options": options_pb2.GetPolicyOptions(requested_policy_version=2598),
            }
        )
        call.assert_called()

@pytest.mark.asyncio
async def test_get_iam_policy_from_dict_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(type(client.transport.get_iam_policy), "__call__") as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            policy_pb2.Policy()
        )

        response = await client.get_iam_policy(
            request={
                "resource": "resource_value",
                "options": options_pb2.GetPolicyOptions(requested_policy_version=2598),
            }
        )
        call.assert_called()
{% endif %}

{% if "TestIamPermissions" in api.mixin_api_methods %}
def test_test_iam_permissions(transport: str = "grpc"):
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(), transport=transport,
    )

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.TestIamPermissionsRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = iam_policy_pb2.TestIamPermissionsResponse(
            permissions=["permissions_value"],
        )

        response = client.test_iam_permissions(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, iam_policy_pb2.TestIamPermissionsResponse)

    assert response.permissions == ["permissions_value"]


@pytest.mark.asyncio
async def test_test_iam_permissions_async(transport: str = "grpc_asyncio"):
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(), transport=transport,
    )

    # Everything is optional in proto3 as far as the runtime is concerned,
    # and we are mocking out the actual API, so just send an empty request.
    request = iam_policy_pb2.TestIamPermissionsRequest()

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            iam_policy_pb2.TestIamPermissionsResponse(permissions=["permissions_value"],)
        )

        response = await client.test_iam_permissions(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls)
        _, args, _ = call.mock_calls[0]

        assert args[0] == request

    # Establish that the response is the type that we expect.
    assert isinstance(response, iam_policy_pb2.TestIamPermissionsResponse)

    assert response.permissions == ["permissions_value"]


def test_test_iam_permissions_field_headers():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.TestIamPermissionsRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        call.return_value = iam_policy_pb2.TestIamPermissionsResponse()

        client.test_iam_permissions(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls) == 1
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]


@pytest.mark.asyncio
async def test_test_iam_permissions_field_headers_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )

    # Any value that is part of the HTTP/1.1 URI should be sent as
    # a field header. Set these to a non-empty value.
    request = iam_policy_pb2.TestIamPermissionsRequest()
    request.resource = "resource/value"

    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            iam_policy_pb2.TestIamPermissionsResponse()
        )

        await client.test_iam_permissions(request)

        # Establish that the underlying gRPC stub method was called.
        assert len(call.mock_calls)
        _, args, _ = call.mock_calls[0]
        assert args[0] == request

    # Establish that the field header was sent.
    _, _, kw = call.mock_calls[0]
    assert ("x-goog-request-params", "resource=resource/value",) in kw["metadata"]


def test_test_iam_permissions_from_dict():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = iam_policy_pb2.TestIamPermissionsResponse()

        response = client.test_iam_permissions(
            request={
                "resource": "resource_value",
                "permissions": ["permissions_value"],
            }
        )
        call.assert_called()

@pytest.mark.asyncio
async def test_test_iam_permissions_from_dict_async():
    client = {{ service.async_client_name }}(
        credentials=async_anonymous_credentials(),
    )
    # Mock the actual call within the gRPC stub, and fake the request.
    with mock.patch.object(
        type(client.transport.test_iam_permissions), "__call__"
    ) as call:
        # Designate an appropriate return value for the call.
        call.return_value = grpc_helpers_async.FakeUnaryUnaryCall(
            iam_policy_pb2.TestIamPermissionsResponse()
        )

        response = await client.test_iam_permissions(
            request={
                "resource": "resource_value",
                "permissions": ["permissions_value"],
            }
        )
        call.assert_called()
{% endif %}
{% endif %}

{# REST transport tests for mixin URL query params encoding #}
{% if 'rest' in opts.transport %}

{# Operations mixin REST URL encoding tests #}
{% if api.has_operations_mixin %}

{% if "ListOperations" in api.mixin_api_methods %}
def test_list_operations_rest_url_query_params_encoding():
    # Verify that special characters like '$' are correctly preserved (not URL-encoded)
    # when building the URL query string for mixin methods.
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.list_operations.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/test/operations',
            'method': 'get',
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "GetOperation" in api.mixin_api_methods %}
def test_get_operation_rest_url_query_params_encoding():
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.get_operation.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/test/operations/op1',
            'method': 'get',
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "DeleteOperation" in api.mixin_api_methods %}
def test_delete_operation_rest_url_query_params_encoding():
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.delete_operation.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.delete.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/test/operations/op1',
            'method': 'delete',
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.delete.called
        call_url = mock_session.delete.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "CancelOperation" in api.mixin_api_methods %}
def test_cancel_operation_rest_url_query_params_encoding():
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.cancel_operation.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.post.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/test/operations/op1:cancel',
            'method': 'post',
            'body': {},
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
            body={},
        )

        assert mock_session.post.called
        call_url = mock_session.post.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% endif %} {# operations_mixin #}

{# Location mixin REST URL encoding tests #}
{% if api.has_location_mixin %}

{% if "ListLocations" in api.mixin_api_methods %}
def test_list_locations_rest_url_query_params_encoding():
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.list_locations.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/projects/p1/locations',
            'method': 'get',
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "GetLocation" in api.mixin_api_methods %}
def test_get_location_rest_url_query_params_encoding():
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.get_location.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/projects/p1/locations/l1',
            'method': 'get',
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% endif %} {# location_mixin #}

{# IAM mixin REST URL encoding tests #}
{% if api.has_iam_mixin or opts.add_iam_methods %}

{% if "SetIamPolicy" in api.mixin_api_methods or opts.add_iam_methods %}
def test_set_iam_policy_rest_url_query_params_encoding():
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.set_iam_policy.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.post.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/resource:setIamPolicy',
            'method': 'post',
            'body': {},
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
            body={},
        )

        assert mock_session.post.called
        call_url = mock_session.post.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "GetIamPolicy" in api.mixin_api_methods or opts.add_iam_methods %}
def test_get_iam_policy_rest_url_query_params_encoding():
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.get_iam_policy.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/resource:getIamPolicy',
            'method': 'get',
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "TestIamPermissions" in api.mixin_api_methods or opts.add_iam_methods %}
def test_test_iam_permissions_rest_url_query_params_encoding():
    transport = transports.{{ service.rest_transport_name }}(credentials=ga_credentials.AnonymousCredentials())
    method_class = transport.test_iam_permissions.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.Mock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.post.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/resource:testIamPermissions',
            'method': 'post',
            'body': {},
        }

        get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
            body={},
        )

        assert mock_session.post.called
        call_url = mock_session.post.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% endif %} {# iam_mixin #}

{% if rest_async_io_enabled %}
{# Async REST URL encoding tests for mixin methods #}

{% if api.has_operations_mixin %}

{% if "ListOperations" in api.mixin_api_methods %}
@pytest.mark.asyncio
async def test_list_operations_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.list_operations.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/test/operations',
            'method': 'get',
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "GetOperation" in api.mixin_api_methods %}
@pytest.mark.asyncio
async def test_get_operation_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.get_operation.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/test/operations/op1',
            'method': 'get',
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "DeleteOperation" in api.mixin_api_methods %}
@pytest.mark.asyncio
async def test_delete_operation_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.delete_operation.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.delete.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/test/operations/op1',
            'method': 'delete',
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.delete.called
        call_url = mock_session.delete.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "CancelOperation" in api.mixin_api_methods %}
@pytest.mark.asyncio
async def test_cancel_operation_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.cancel_operation.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.post.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/test/operations/op1:cancel',
            'method': 'post',
            'body': {},
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
            body={},
        )

        assert mock_session.post.called
        call_url = mock_session.post.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% endif %} {# operations_mixin #}

{% if api.has_location_mixin %}

{% if "ListLocations" in api.mixin_api_methods %}
@pytest.mark.asyncio
async def test_list_locations_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.list_locations.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/projects/p1/locations',
            'method': 'get',
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "GetLocation" in api.mixin_api_methods %}
@pytest.mark.asyncio
async def test_get_location_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.get_location.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/projects/p1/locations/l1',
            'method': 'get',
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% endif %} {# location_mixin #}

{% if api.has_iam_mixin or opts.add_iam_methods %}

{% if "SetIamPolicy" in api.mixin_api_methods or opts.add_iam_methods %}
@pytest.mark.asyncio
async def test_set_iam_policy_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.set_iam_policy.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.post.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/resource:setIamPolicy',
            'method': 'post',
            'body': {},
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
            body={},
        )

        assert mock_session.post.called
        call_url = mock_session.post.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "GetIamPolicy" in api.mixin_api_methods or opts.add_iam_methods %}
@pytest.mark.asyncio
async def test_get_iam_policy_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.get_iam_policy.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.get.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/resource:getIamPolicy',
            'method': 'get',
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
        )

        assert mock_session.get.called
        call_url = mock_session.get.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% if "TestIamPermissions" in api.mixin_api_methods or opts.add_iam_methods %}
@pytest.mark.asyncio
async def test_test_iam_permissions_rest_asyncio_url_query_params_encoding():
    if not HAS_ASYNC_REST_EXTRA:
        pytest.skip("the library must be installed with the `async_rest` extra to test this feature.")
    transport = transports.Async{{ service.name }}RestTransport(credentials=async_anonymous_credentials())
    method_class = transport.test_iam_permissions.__class__
    get_response_fn = method_class._get_response

    mock_session = mock.AsyncMock()
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_session.post.return_value = mock_response

    with mock.patch.object(rest_helpers, 'flatten_query_params') as mock_flatten:
        mock_flatten.return_value = [('$alt', 'json;enum-encoding=int'), ('foo', 'bar')]

        transcoded_request = {
            'uri': '/v1/resource:testIamPermissions',
            'method': 'post',
            'body': {},
        }

        await get_response_fn(
            host='https://example.com',
            metadata=[],
            query_params={},
            session=mock_session,
            timeout=None,
            transcoded_request=transcoded_request,
            body={},
        )

        assert mock_session.post.called
        call_url = mock_session.post.call_args.args[0]
        assert '$alt=json' in call_url
        assert '%24alt' not in call_url
        assert 'foo=bar' in call_url
{% endif %}

{% endif %} {# iam_mixin #}

{% endif %} {# rest_async_io_enabled #}

{% endif %} {# rest transport #}
