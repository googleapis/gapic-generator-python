{% if service.has_resumable_upload %}
# -*- coding: utf-8 -*-
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import dataclasses
import json  # type: ignore
import logging
import os
import sys
from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union, BinaryIO
import warnings
from datetime import datetime, timedelta, timezone

from google.api_core import exceptions as core_exceptions
from google.api_core import gapic_v1, rest_helpers, rest_streaming
from google.api_core import retry as retries
from google.auth import credentials as ga_credentials  # type: ignore
from google.auth.transport.requests import AuthorizedSession  # type: ignore

import google.protobuf
from google.protobuf import empty_pb2  # type: ignore
from google.protobuf import json_format
from requests import __version__ as requests_version

{% filter sort_lines %}
{% for method in service.methods.values() if method.is_resumable_upload %}
{{ method.input.ident.python_import }}
{{ method.output.ident.python_import }}
{% endfor %}
{% endfilter %}

from .base import DEFAULT_CLIENT_INFO as BASE_DEFAULT_CLIENT_INFO
from .rest_resumable_base import _Base{{ service.name }}RestResumableTransport
from .resumable_upload import ResumableUpload, make_resumable_upload


try:
    OptionalRetry = Union[retries.Retry, gapic_v1.method._MethodDefault, None]
except AttributeError:  # pragma: NO COVER
    OptionalRetry = Union[retries.Retry, object, None]  # type: ignore

_DEFAULT_CHUNK_SIZE = 10 * 1024 * 1024 # 10MB
_DEFAULT_TIMEOUT = 14400
_DEFAULT_CONTENT_TYPE = "application/octet-stream"

_DEFAULT_RETRY = retries.Retry(predicate=retries.if_exception_type(
    core_exceptions.ServiceUnavailable,
    core_exceptions.DeadlineExceeded,
), initial=1.0, maximum=60.0, multiplier=1.3)

DEFAULT_CLIENT_INFO = gapic_v1.client_info.ClientInfo()

if hasattr(DEFAULT_CLIENT_INFO, "protobuf_runtime_version"):  # pragma: NO COVER
    DEFAULT_CLIENT_INFO.protobuf_runtime_version = google.protobuf.__version__

class {{ service.name }}RestResumableInterceptor:
    """Interceptor for {{ service.name }}. Not implemented yet"""

class {{ service.name }}RestResumableTransport(_Base{{ service.name }}RestResumableTransport):
    """REST backend synchronous transport for {{ service.name }}.
    It is only used by Resumable Media Upload functionality
    """

    def __init__(
        self,
        *,
        host: str = "{{ service.host }}",
        credentials: Optional[ga_credentials.Credentials] = None,
        credentials_file: Optional[str] = None,
        scopes: Optional[Sequence[str]] = None,
        client_cert_source_for_mtls: Optional[Callable[[], Tuple[bytes, bytes]]] = None,
        quota_project_id: Optional[str] = None,
        client_info: gapic_v1.client_info.ClientInfo = DEFAULT_CLIENT_INFO,
        always_use_jwt_access: Optional[bool] = False,        url_scheme: str = "https",
        interceptor: Optional[{{ service.name }}RestResumableInterceptor] = None,
        api_audience: Optional[str] = None,
        **kwargs # Catch-all for forward compatibility
    ) -> None:
        """Instantiate the transport.

        Args:
            host (Optional[str]):
                 The hostname to connect to (default: '{{ service.host }}').
            credentials (Optional[google.auth.credentials.Credentials]): The
                authorization credentials to attach to requests. These
                credentials identify the application to the service; if none
                are specified, the client will attempt to ascertain the
                credentials from the environment.

            credentials_file (Optional[str]): Deprecated. A file with credentials that can
                be loaded with :func:`google.auth.load_credentials_from_file`.
                This argument is ignored if ``channel`` is provided. This argument will be
                removed in the next major version of this library.
            scopes (Optional(Sequence[str])): A list of scopes. This argument is
                ignored if ``channel`` is provided.
            client_cert_source_for_mtls (Callable[[], Tuple[bytes, bytes]]): Client
                certificate to configure mutual TLS HTTP channel. It is ignored
                if ``channel`` is provided.
            quota_project_id (Optional[str]): An optional project to use for billing
                and quota.
            client_info (google.api_core.gapic_v1.client_info.ClientInfo):
                The client info used to send a user-agent string along with
                API requests. If ``None``, then default info will be used.
                Generally, you only need to set this if you are developing
                your own client library.
            always_use_jwt_access (Optional[bool]): Whether self signed JWT should
                be used for service account credentials.
            url_scheme: the protocol scheme for the API endpoint.  Normally
                "https", but for testing or local servers,
                "http" can be specified.
        """
        # Run the base constructor
        super().__init__(
            host=host,
            credentials=credentials,
            client_info=client_info,
            always_use_jwt_access=always_use_jwt_access,
            url_scheme=url_scheme,
            api_audience=api_audience,
        )
        self._session = AuthorizedSession(
            self._credentials, default_host=self.DEFAULT_HOST
        )
        if client_cert_source_for_mtls:
            self._session.configure_mtls_channel(client_cert_source_for_mtls)

    @staticmethod
    def _maybe_rewind(stream, rewind=False):
        """Rewind the stream if desired.

        :type stream: IO[bytes]
        :param stream: A bytes IO object open for reading.

        :type rewind: bool
        :param rewind: Indicates if we should seek to the beginning of the stream.
        """
        if rewind:
            stream.seek(0, os.SEEK_SET)

    {% for method in service.methods.values() if method.is_resumable_upload %}
    def {{ method.name|snake_case }}_resumable(self,
        request: {{ method.input.ident }},
        *,
        stream: BinaryIO,
        rewind: bool = False,
        size: Optional[int] = None,
        content_type: Optional[str] = None,
        chunk_size: Optional[int] = None,
        retry: OptionalRetry = gapic_v1.method.DEFAULT,
        timeout: Union[float, object] = gapic_v1.method.DEFAULT,
        metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),
        ) -> {{ method.output.ident }}:
        r"""{{ method.meta.doc }}

        Args:
            request (Union[{{ method.input.ident }}, dict]):
                The request object. Request message for
                [{{ service.name }}.{{ method.name }}][].
            stream (BinaryIO): A stream of bytes, such as a file opened in binary mode for reading.
            rewind: If True, seek to the beginning of the file handle before uploading from the stream.
            size: The number of bytes to be uploaded (which will be read from
                ``stream``). If not provided, the upload will be concluded once
                ``stream`` is exhausted.
            retry (google.api_core.retry.Retry): Designation of what errors, if any,
                should be retried.
            timeout (float): The timeout for this request.
            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be
                sent along with the request as metadata. Normally, each value must be of type `str`,
                but for metadata keys ending with the suffix `-bin`, the corresponding values must
                be of type `bytes`.

        Returns:
            {{ method.output.ident }}:
                Response message for
                [{{ service.name }}.{{ method.name }}][].

        """

        self._maybe_rewind(stream, rewind=rewind)

        http_options = _Base{{ service.name }}RestResumableTransport._Base{{ method.name }}Request._get_http_options()
        transcoded_request = _Base{{ service.name }}RestResumableTransport._Base{{ method.name }}Request._get_transcoded_request(http_options, request)
        request_url = "{host}/resumable/upload{uri}".format(host=self._host, uri=transcoded_request['uri'])

        # preserving_proto_field_name=True ensures we get snake case "customer_id" 
        json_body = json_format.MessageToJson(
            request._pb,
            preserving_proto_field_name=True,
        )

        if chunk_size is None:
            chunk_size = _DEFAULT_CHUNK_SIZE
        if retry is gapic_v1.method.DEFAULT:
            retry = _DEFAULT_RETRY
        if timeout is None or timeout is gapic_v1.method.DEFAULT:
            timeout = _DEFAULT_TIMEOUT
        if content_type is None:
            content_type = _DEFAULT_CONTENT_TYPE

        deadline = datetime.now(timezone.utc) + timedelta(seconds=timeout)
        headers = dict(metadata)

        response = make_resumable_upload(
            transport=self._session,
            request_body=json_body,
            stream=stream,
            upload_url=request_url,
            size=size,
            content_type=content_type,
            chunk_size=chunk_size,
            request_retry=retry,
            deadline=deadline,
            headers=headers,
            on_progress=None
        )  

        data = response.json()
        response_message = {{ method.output.ident }}()
        json_format.ParseDict(data, response_message._pb, ignore_unknown_fields=True)
        
        return response_message
    {% endfor %}

__all__ = ("{{ service.name }}RestResumableTransport",)
{% endif %}
