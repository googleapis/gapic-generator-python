{#
 # Copyright (C) 2024  Google LLC
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
#}

{% macro auto_populate_uuid4_fields(api, method) %}
{#
    Automatically populate UUID4 fields according to
    https://google.aip.dev/client-libraries/4235 when the
    field satisfies either of:
    - The field supports explicit presence and has not been set by the user.
    - The field doesn't support explicit presence, and its value is the empty
      string (i.e. the default value).
    When using this macro, ensure the calling template generates a line `import uuid`
#}
{% with method_settings = api.all_method_settings.get(method.meta.address.proto) %}
{% if method_settings is not none %}
{% for auto_populated_field in method_settings.auto_populated_fields %}
    {% if method.input.fields[auto_populated_field].proto3_optional %}
        if '{{ auto_populated_field }}' not in request:
    {% else %}
        if not request.{{ auto_populated_field }}:
    {% endif %}
            request.{{ auto_populated_field }} = str(uuid.uuid4())
{% endfor %}
{% endif %}{# if method_settings is not none #}
{% endwith %}{# method_settings #}
{% endmacro %}

{% macro add_google_api_core_version_header_import(service_version) %}
{#
The `version_header` module was added to `google-api-core`
in version 2.19.0.
https://github.com/googleapis/python-api-core/releases/tag/v2.19.0
The `try/except` below can be removed once the minimum version of
`google-api-core` is 2.19.0 or newer.
#}
{% if service_version %}
try:
    from google.api_core import version_header
    HAS_GOOGLE_API_CORE_VERSION_HEADER = True  # pragma: NO COVER
except ImportError:  # pragma: NO COVER
    HAS_GOOGLE_API_CORE_VERSION_HEADER = False
{% endif %}{# service_version #}
{% endmacro %}

{% macro add_api_version_header_to_metadata(service_version) %}
{#
    Add API Version to metadata as per https://github.com/aip-dev/google.aip.dev/pull/1331.
    When using this macro, ensure the calling template also calls macro
    `add_google_api_core_version_header_import` to add the necessary import statements.
#}
    {% if service_version %}
        if HAS_GOOGLE_API_CORE_VERSION_HEADER:  # pragma: NO COVER
            metadata = tuple(metadata) + (
                version_header.to_api_version_header("{{ service_version }}"),
            )
    {% endif %}{# service_version #}
{% endmacro %}

{% macro operations_mixin_imports(api, service, opts) %}
{% if import_ns is not defined %}
{% set import_ns = namespace(has_operations_mixin=false) %}
{% endif %}{# import_ns is not defined #}
{% set import_ns.has_operations_mixin = api.has_operations_mixin %}

{% filter sort_lines %}
{% for method in service.methods.values() %}
{{method.input.ident.python_import}}
{% if method.output.ident|string() == "operations_pb2.Operation" %}
{% set import_ns.has_operations_mixin = True %}
{% else %}
{{method.output.ident.python_import}}
{% endif %}
{% endfor %}
{% if opts.add_iam_methods %}
from google.iam.v1 import iam_policy_pb2  # type: ignore
from google.iam.v1 import policy_pb2  # type: ignore
{% endif %}{# opts.add_iam_methods #}
{% endfilter %}
{% if import_ns.has_operations_mixin %}
from google.longrunning import operations_pb2  # type: ignore
{% endif %}{# import_ns.has_operations_mixin #}
{% endmacro %}

{% macro http_options_method(rules) %}
@staticmethod
def _get_http_options():
    http_options: List[Dict[str, str]] = [
    {%- for rule in rules %}{
        'method': '{{ rule.method }}',
        'uri': '{{ rule.uri }}',
        {% if rule.body %}
        'body': '{{ rule.body }}',
        {% endif %}{# rule.body #}
    },
    {% endfor %}{# rule in rules #}
    ]
    return http_options
{% endmacro %}

{% macro response_method(body_spec) %}
@staticmethod
def _get_response(
    host,
    metadata,
    query_params,
    session,
    timeout,
    transcoded_request,
    body=None):
    
    uri = transcoded_request['uri']
    method = transcoded_request['method']
    headers = dict(metadata)
    headers['Content-Type'] = 'application/json'
    response = getattr(session, method)(
        "{host}{uri}".format(host=host, uri=uri),
        timeout=timeout,
        headers=headers,
        params=rest_helpers.flatten_query_params(query_params, strict=True),
        {% if body_spec %}
        data=body,
        {% endif %}
        )
    return response
{% endmacro %}

{% macro rest_call_method_common(body_spec, method_name, service_name) %}

    http_options = _Base{{ service_name }}RestTransport._Base{{method_name}}._get_http_options()
    request, metadata = self._interceptor.pre_{{ method_name|snake_case }}(request, metadata)
    transcoded_request = _Base{{ service_name }}RestTransport._Base{{method_name}}._get_transcoded_request(http_options, request)

    {% if body_spec %}
    body = _Base{{ service_name }}RestTransport._Base{{method_name}}._get_request_body_json(transcoded_request)
    {% endif %} {# body_spec #}

    # Jsonify the query params
    query_params = _Base{{ service_name }}RestTransport._Base{{method_name}}._get_query_params_json(transcoded_request)

    # Send the request
    response = {{ service_name }}RestTransport._{{method_name}}._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request{% if body_spec %}, body{% endif %})

    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception
    # subclass.
    if response.status_code >= 400:
        raise core_exceptions.from_http_response(response)

{% endmacro %}


{% macro prep_wrapped_messages_async_method(service) %}
def _prep_wrapped_messages(self, client_info):
    """ Precompute the wrapped methods, overriding the base class method to use async wrappers."""
    self._wrapped_methods = {
        {% for method in service.methods.values() %}
        self.{{ method.transport_safe_name|snake_case }}: self._wrap_method(
            self.{{ method.transport_safe_name|snake_case }},
            {% if method.retry %}
            default_retry=retries.AsyncRetry(
                {% if method.retry.initial_backoff %}
                initial={{ method.retry.initial_backoff }},
                {% endif %}
                {% if method.retry.max_backoff %}
                maximum={{ method.retry.max_backoff }},
                {% endif %}
                {% if method.retry.backoff_multiplier %}
                multiplier={{ method.retry.backoff_multiplier }},
                {% endif %}
                predicate=retries.if_exception_type(
                    {% for ex in method.retry.retryable_exceptions|sort(attribute='__name__') %}
                    core_exceptions.{{ ex.__name__ }},
                    {% endfor %}
                ),
                deadline={{ method.timeout }},
            ),
            {% endif %}
            default_timeout={{ method.timeout }},
            client_info=client_info,
        ),
        {% endfor %}{# service.methods.values() #}
    }
{% endmacro %}

{# TODO: This helper logic to check whether `kind` needs to be configured in wrap_method
can be removed once we require the correct version of the google-api-core dependency to
avoid having a gRPC code path in an async REST call.
See related issue: https://github.com/googleapis/python-api-core/issues/661.
In the meantime, if an older version of the dependency is installed (which has a wrap_method with
no kind parameter), then an async gRPC call will work correctly and async REST transport
will not be available as a transport.
See related issue: https://github.com/googleapis/gapic-generator-python/issues/2119. #}
{% macro wrap_async_method_macro() %}
def _wrap_method(self, func, *args, **kwargs):
    {# TODO: Remove `pragma: NO COVER` once https://github.com/googleapis/python-api-core/pull/688 is merged. #}
    if self._wrap_with_kind:  # pragma: NO COVER
        kwargs["kind"] = self.kind
    return gapic_v1.method_async.wrap_method(func, *args, **kwargs)
{% endmacro %}
