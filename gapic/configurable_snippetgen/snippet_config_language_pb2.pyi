"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2022 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _GeneratorOutputLanguage:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _GeneratorOutputLanguageEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_GeneratorOutputLanguage.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    GENERATOR_OUTPUT_LANGUAGE_UNSPECIFIED: _GeneratorOutputLanguage.ValueType  # 0
    """The language has not been specified. Consumers should not see this value."""
    C_PLUS_PLUS: _GeneratorOutputLanguage.ValueType  # 1
    C_SHARP: _GeneratorOutputLanguage.ValueType  # 2
    GO: _GeneratorOutputLanguage.ValueType  # 3
    JAVA: _GeneratorOutputLanguage.ValueType  # 4
    JAVASCRIPT: _GeneratorOutputLanguage.ValueType  # 5
    PHP: _GeneratorOutputLanguage.ValueType  # 6
    PYTHON: _GeneratorOutputLanguage.ValueType  # 7
    RUBY: _GeneratorOutputLanguage.ValueType  # 8

class GeneratorOutputLanguage(_GeneratorOutputLanguage, metaclass=_GeneratorOutputLanguageEnumTypeWrapper):
    """A programming language in which snippets are generated.
    Note that this is different from
    google.cloud.tools.snippetgen.snippetindex.v1.Language, i.e. language
    specified in snippet metadata, as metadata can be written for both generated
    and handwritten snippets. In turn, we'll always know which generators we are
    writing snippet configs for and which are the output languages of those
    generators.
    """

GENERATOR_OUTPUT_LANGUAGE_UNSPECIFIED: GeneratorOutputLanguage.ValueType  # 0
"""The language has not been specified. Consumers should not see this value."""
C_PLUS_PLUS: GeneratorOutputLanguage.ValueType  # 1
C_SHARP: GeneratorOutputLanguage.ValueType  # 2
GO: GeneratorOutputLanguage.ValueType  # 3
JAVA: GeneratorOutputLanguage.ValueType  # 4
JAVASCRIPT: GeneratorOutputLanguage.ValueType  # 5
PHP: GeneratorOutputLanguage.ValueType  # 6
PYTHON: GeneratorOutputLanguage.ValueType  # 7
RUBY: GeneratorOutputLanguage.ValueType  # 8
global___GeneratorOutputLanguage = GeneratorOutputLanguage

@typing_extensions.final
class SnippetConfig(google.protobuf.message.Message):
    """The snippet configuration for a single snippet that will be generated across
    all languages.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METADATA_FIELD_NUMBER: builtins.int
    RPC_FIELD_NUMBER: builtins.int
    SIGNATURE_FIELD_NUMBER: builtins.int
    SNIPPET_FIELD_NUMBER: builtins.int
    @property
    def metadata(self) -> global___SnippetConfigMetadata:
        """Metadata for the snippet configuration. Some information contained here
        will be included in the generated snippet own metadata.
        """
    @property
    def rpc(self) -> global___Rpc:
        """The RPC this snippet is for."""
    @property
    def signature(self) -> global___SnippetSignature:
        """The generated snippet method signature."""
    @property
    def snippet(self) -> global___Snippet:
        """The actual snippet (code)."""
    def __init__(
        self,
        *,
        metadata: global___SnippetConfigMetadata | None = ...,
        rpc: global___Rpc | None = ...,
        signature: global___SnippetSignature | None = ...,
        snippet: global___Snippet | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metadata", b"metadata", "rpc", b"rpc", "signature", b"signature", "snippet", b"snippet"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["metadata", b"metadata", "rpc", b"rpc", "signature", b"signature", "snippet", b"snippet"]) -> None: ...

global___SnippetConfig = SnippetConfig

@typing_extensions.final
class SnippetConfigMetadata(google.protobuf.message.Message):
    """Metadata for the snippet configuration. Some information contained here will
    be included in the generated snippet's own metadata.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SKIPPED_FIELD_NUMBER: builtins.int
    SKIPPED_LANGUAGES_FIELD_NUMBER: builtins.int
    CONFIG_ID_FIELD_NUMBER: builtins.int
    SNIPPET_NAME_FIELD_NUMBER: builtins.int
    SNIPPET_DESCRIPTION_FIELD_NUMBER: builtins.int
    skipped: builtins.bool
    """Whether this snippet config should be skipped for/ generation.
    This is useful when snippets are developed before features are released.
    Defaults to false.
    """
    @property
    def skipped_languages(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___GeneratorOutputLanguage.ValueType]:
        """List of languages to skip snippet generation for.
        Config producers should specify here languages for which some of the
        capabilities required by the snippet are not supported. For instance, if a
        specific client option is required by the snippet, and that option is not
        supported by .NET client libraries, then C_SHARP should be specified here.
        """
    config_id: builtins.str
    """The config id. This will be used to generate the region tag of the snippet.
    Required.
    The region tag format will be:
    [{START|END}
    ${apishortname}_${apiVersion}_config_${ServiceName}_${RpcName}_${config_id}_{sync|async}]
    - config_id must be unique for a given Service/RPC pair.
    - config_id must not contain the API, Service or RPC identifiers as that
      will be automatically included in the region tag.
    - config_id may only contain letters and numbers
    - config_id should be PascalCased
    - Preferable, config_id should not exceed 50 characters, although this is
    not a hard requirement.
    - config_id may be somewhat descriptive of the snippet or just a random
    identifier. If it's descriptive, do not make it overly verbose, there are
    the human readable snippet_name and snippet_description fields for properly
    describing the snippet. For instance, prefer DefaultDatasetCreation to
    DatasetCreationUsingDefaultValuesExceptForDatasetNameWhichIsRequired.
    """
    snippet_name: builtins.str
    """The human readable name of the snippet.
    To be included in metadata and in the sample itself in the top-level
    description.
    """
    snippet_description: builtins.str
    """The description of the snippet.
    To be included in metadata and in the sample itself in the top-level
    description.
    """
    def __init__(
        self,
        *,
        skipped: builtins.bool = ...,
        skipped_languages: collections.abc.Iterable[global___GeneratorOutputLanguage.ValueType] | None = ...,
        config_id: builtins.str = ...,
        snippet_name: builtins.str = ...,
        snippet_description: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["config_id", b"config_id", "skipped", b"skipped", "skipped_languages", b"skipped_languages", "snippet_description", b"snippet_description", "snippet_name", b"snippet_name"]) -> None: ...

global___SnippetConfigMetadata = SnippetConfigMetadata

@typing_extensions.final
class Rpc(google.protobuf.message.Message):
    """An RPC for which a Snippet may be defined."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROTO_PACKAGE_FIELD_NUMBER: builtins.int
    API_VERSION_FIELD_NUMBER: builtins.int
    SERVICE_NAME_FIELD_NUMBER: builtins.int
    RPC_NAME_FIELD_NUMBER: builtins.int
    proto_package: builtins.str
    """This is identical to the protobuf package ending with a version number,
    after removing said version number. For instance, where the api ID is
    "google.cloud.translate.v3" the API name is "google.cloud.translate".
    """
    @property
    def api_version(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The list of API versions for which one snippet is defined.
        The same RPC may exist in different versions (v1, v1beta, v2) of the API
        and may be covered by the same snippet config.
        """
    service_name: builtins.str
    """The protobuf service name relative to the api name + version where the RPC
    is defined. Example: "TransalationService".
    """
    rpc_name: builtins.str
    """The RPC name relative to the service name."""
    def __init__(
        self,
        *,
        proto_package: builtins.str = ...,
        api_version: collections.abc.Iterable[builtins.str] | None = ...,
        service_name: builtins.str = ...,
        rpc_name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["api_version", b"api_version", "proto_package", b"proto_package", "rpc_name", b"rpc_name", "service_name", b"service_name"]) -> None: ...

global___Rpc = Rpc

@typing_extensions.final
class SnippetSignature(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SyncPreference:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SyncPreferenceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SnippetSignature._SyncPreference.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        LANGUAGE_PREFERRED: SnippetSignature._SyncPreference.ValueType  # 0
        """Generate an async, sync or both snippets as per language
        (style, guidelines, community) preference.
        """
        PREFER_ASYNC: SnippetSignature._SyncPreference.ValueType  # 1
        """Languages supporting async methods should generate an async snippet.
        Languages that do not support async methods will generate a sync snippet
        instead.
        """
        PREFER_SYNC: SnippetSignature._SyncPreference.ValueType  # 2
        """Languages supporting sync methods should generate a sync snippet.
        Languages that do not support sync methods will generate an async snippet
        instead.
        """
        BOTH: SnippetSignature._SyncPreference.ValueType  # 3
        """Languages that support both async and sync methods should generate both a
        sync and an async snippets. Note that different samples should be in
        differnt files.
        Languages that support only one of async and sync methods should
        generate the supported snippet.
        """

    class SyncPreference(_SyncPreference, metaclass=_SyncPreferenceEnumTypeWrapper):
        """Synchronous preference indicator for the generated snippet.
        Note that some languages only support one-off sync or async methods so this
        is just a preference indicator.
        """

    LANGUAGE_PREFERRED: SnippetSignature.SyncPreference.ValueType  # 0
    """Generate an async, sync or both snippets as per language
    (style, guidelines, community) preference.
    """
    PREFER_ASYNC: SnippetSignature.SyncPreference.ValueType  # 1
    """Languages supporting async methods should generate an async snippet.
    Languages that do not support async methods will generate a sync snippet
    instead.
    """
    PREFER_SYNC: SnippetSignature.SyncPreference.ValueType  # 2
    """Languages supporting sync methods should generate a sync snippet.
    Languages that do not support sync methods will generate an async snippet
    instead.
    """
    BOTH: SnippetSignature.SyncPreference.ValueType  # 3
    """Languages that support both async and sync methods should generate both a
    sync and an async snippets. Note that different samples should be in
    differnt files.
    Languages that support only one of async and sync methods should
    generate the supported snippet.
    """

    SNIPPET_METHOD_NAME_FIELD_NUMBER: builtins.int
    RETURN_TYPE_FIELD_NUMBER: builtins.int
    SYNC_PREFERENCE_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    snippet_method_name: builtins.str
    """The name for the snippet method specified in snake_case. Required."""
    @property
    def return_type(self) -> global___Type:
        """The return type for the snippet method. Unset for methods that do not
        return a value or if the sample is to be generated for non statically-typed
        languages only.
        """
    sync_preference: global___SnippetSignature.SyncPreference.ValueType
    """Synchronous preference indicator for the generated snippet."""
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement.Declaration]:
        """The list of parameters that the snippet will receive. May be empty if the
        snippet method does not receive parameters. If any, parameters should
        appear in generated code in the same order as they appear in this field.
        Note also that if parameters have assignments, some languages
        will represent these as default parameter values which are
        usually scalars.
        """
    def __init__(
        self,
        *,
        snippet_method_name: builtins.str = ...,
        return_type: global___Type | None = ...,
        sync_preference: global___SnippetSignature.SyncPreference.ValueType = ...,
        parameters: collections.abc.Iterable[global___Statement.Declaration] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["return_type", b"return_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["parameters", b"parameters", "return_type", b"return_type", "snippet_method_name", b"snippet_method_name", "sync_preference", b"sync_preference"]) -> None: ...

global___SnippetSignature = SnippetSignature

@typing_extensions.final
class Snippet(google.protobuf.message.Message):
    """The actual snippet (code), including client and request initialization,
    client call and response handling.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ClientInitialization(google.protobuf.message.Message):
        """Options to initialize the client with."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing_extensions.final
        class ServiceEndpoint(google.protobuf.message.Message):
            """Different languages have different requirements for how a service
            endpoint should be specified, so in sample configuration the endpoint
            needs to be specified in parts that each language generator can then use
            to compose the string literal to include in the sample according to their
            own requirements. None of this manipulation should be included in the
            sample itself, where only a string literal is expected as the value for
            the custom endpoint.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            class _ServiceEndpointSchema:
                ValueType = typing.NewType("ValueType", builtins.int)
                V: typing_extensions.TypeAlias = ValueType

            class _ServiceEndpointSchemaEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Snippet.ClientInitialization.ServiceEndpoint._ServiceEndpointSchema.ValueType], builtins.type):  # noqa: F821
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
                LANGUAGE_DEFAULT: Snippet.ClientInitialization.ServiceEndpoint._ServiceEndpointSchema.ValueType  # 0
                """Each language to use their own default.
                Languages that do not require the schema to be specified,
                may omit it when building the custom endpoint.
                Languages that require the schema to be specified should use the
                same default value as they do in library generation.
                """
                HTTPS: Snippet.ClientInitialization.ServiceEndpoint._ServiceEndpointSchema.ValueType  # 1
                """Use HTTPS for service endpoint schema."""
                HTTP: Snippet.ClientInitialization.ServiceEndpoint._ServiceEndpointSchema.ValueType  # 2
                """Use HTTP for service endpoint schema."""

            class ServiceEndpointSchema(_ServiceEndpointSchema, metaclass=_ServiceEndpointSchemaEnumTypeWrapper):
                """Schemas for the service endpoint."""

            LANGUAGE_DEFAULT: Snippet.ClientInitialization.ServiceEndpoint.ServiceEndpointSchema.ValueType  # 0
            """Each language to use their own default.
            Languages that do not require the schema to be specified,
            may omit it when building the custom endpoint.
            Languages that require the schema to be specified should use the
            same default value as they do in library generation.
            """
            HTTPS: Snippet.ClientInitialization.ServiceEndpoint.ServiceEndpointSchema.ValueType  # 1
            """Use HTTPS for service endpoint schema."""
            HTTP: Snippet.ClientInitialization.ServiceEndpoint.ServiceEndpointSchema.ValueType  # 2
            """Use HTTP for service endpoint schema."""

            SCHEMA_FIELD_NUMBER: builtins.int
            HOST_FIELD_NUMBER: builtins.int
            REGION_FIELD_NUMBER: builtins.int
            PORT_FIELD_NUMBER: builtins.int
            schema: global___Snippet.ClientInitialization.ServiceEndpoint.ServiceEndpointSchema.ValueType
            """The schema for the service endpoint."""
            host: builtins.str
            """The unregionalized host for the service endpoint.
            For instance "pubsub.googleapis.com". Required.
            """
            region: builtins.str
            """The region if this is a regional endpoint.
            For instance "us-east1". Optional.
            If present the regional host should be constructed as follows:
            {region}-{host}.
            """
            port: builtins.int
            """The port for the service endpoint. Optional.
            Languages that require a port to be specified should use the same
            default value as they do in library generation.
            """
            def __init__(
                self,
                *,
                schema: global___Snippet.ClientInitialization.ServiceEndpoint.ServiceEndpointSchema.ValueType = ...,
                host: builtins.str = ...,
                region: builtins.str = ...,
                port: builtins.int = ...,
            ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["host", b"host", "port", b"port", "region", b"region", "schema", b"schema"]) -> None: ...

        PRE_CLIENT_INITIALIZATION_FIELD_NUMBER: builtins.int
        CUSTOM_SERVICE_ENDPOINT_FIELD_NUMBER: builtins.int
        @property
        def pre_client_initialization(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
            """Statements to be executed before the service client is initialized. For
            instance, some Statement.Declaration statements of variables to be used
            in service client initialization. May be empty. If any, statements will
            be executed in the same order as they appear on
            pre_request_initialization.
            """
        @property
        def custom_service_endpoint(self) -> global___Snippet.ClientInitialization.ServiceEndpoint:
            """Custom endpoint to use in client initialization. Optional."""
        def __init__(
            self,
            *,
            pre_client_initialization: collections.abc.Iterable[global___Statement] | None = ...,
            custom_service_endpoint: global___Snippet.ClientInitialization.ServiceEndpoint | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["custom_service_endpoint", b"custom_service_endpoint"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["custom_service_endpoint", b"custom_service_endpoint", "pre_client_initialization", b"pre_client_initialization"]) -> None: ...

    @typing_extensions.final
    class Standard(google.protobuf.message.Message):
        """A standard RPC operation."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        REQUEST_INITIALIZATION_FIELD_NUMBER: builtins.int
        CALL_FIELD_NUMBER: builtins.int
        RESPONSE_HANDLING_FIELD_NUMBER: builtins.int
        @property
        def request_initialization(self) -> global___Snippet.SimpleRequestInitialization:
            """Describes how to initialize the request object. Required."""
        @property
        def call(self) -> global___Snippet.ClientCall:
            """Client call configuration. Optional."""
        @property
        def response_handling(self) -> global___Snippet.SimpleResponseHandling:
            """Describes how to handle simple responses. Optional."""
        def __init__(
            self,
            *,
            request_initialization: global___Snippet.SimpleRequestInitialization | None = ...,
            call: global___Snippet.ClientCall | None = ...,
            response_handling: global___Snippet.SimpleResponseHandling | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["call", b"call", "request_initialization", b"request_initialization", "response_handling", b"response_handling"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["call", b"call", "request_initialization", b"request_initialization", "response_handling", b"response_handling"]) -> None: ...

    @typing_extensions.final
    class Paginated(google.protobuf.message.Message):
        """A paginated RPC operation."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        REQUEST_INITIALIZATION_FIELD_NUMBER: builtins.int
        PAGINATED_CALL_FIELD_NUMBER: builtins.int
        PAGINATED_HANDLING_FIELD_NUMBER: builtins.int
        @property
        def request_initialization(self) -> global___Snippet.SimpleRequestInitialization:
            """Describes how to initialize the request object. This is the request
            object used for the initial paginated RPC call. Depending on how the
            response should be handled subsequent requests will be initialized either
            implicitly by the library or explicitly by the snippet.
            """
        @property
        def paginated_call(self) -> global___Snippet.ClientCall:
            """Client call configuration. Optional.
            This configures the client call, which in turn may result in several RPC
            calls. How this configuration is applied to RPC calls may be language
            specific.
            """
        @property
        def paginated_handling(self) -> global___Snippet.PaginatedResponseHandling:
            """Describes how to handle paginated responses."""
        def __init__(
            self,
            *,
            request_initialization: global___Snippet.SimpleRequestInitialization | None = ...,
            paginated_call: global___Snippet.ClientCall | None = ...,
            paginated_handling: global___Snippet.PaginatedResponseHandling | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["paginated_call", b"paginated_call", "paginated_handling", b"paginated_handling", "request_initialization", b"request_initialization"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["paginated_call", b"paginated_call", "paginated_handling", b"paginated_handling", "request_initialization", b"request_initialization"]) -> None: ...

    @typing_extensions.final
    class Lro(google.protobuf.message.Message):
        """A long-running RPC operation."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        REQUEST_INITIALIZATION_FIELD_NUMBER: builtins.int
        CALL_FIELD_NUMBER: builtins.int
        LRO_HANDLING_FIELD_NUMBER: builtins.int
        @property
        def request_initialization(self) -> global___Snippet.SimpleRequestInitialization:
            """Describes how to initialize the request object. Required.
            This describes the request to the LRO operation itself and not to polling
            operations.
            """
        @property
        def call(self) -> global___Snippet.ClientCall:
            """Client call configuration. Optional.
            This configures the call to the LRO operation itself and not to polling
            operations.
            """
        @property
        def lro_handling(self) -> global___Snippet.LroResponseHandling:
            """Describes how to handle the LRO response. Required."""
        def __init__(
            self,
            *,
            request_initialization: global___Snippet.SimpleRequestInitialization | None = ...,
            call: global___Snippet.ClientCall | None = ...,
            lro_handling: global___Snippet.LroResponseHandling | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["call", b"call", "lro_handling", b"lro_handling", "request_initialization", b"request_initialization"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["call", b"call", "lro_handling", b"lro_handling", "request_initialization", b"request_initialization"]) -> None: ...

    @typing_extensions.final
    class ClientStreaming(google.protobuf.message.Message):
        """A client streaming RPC operation."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        INITIALIZATION_CALL_FIELD_NUMBER: builtins.int
        CLIENT_STREAM_NAME_FIELD_NUMBER: builtins.int
        REQUEST_INITIALIZATION_FIELD_NUMBER: builtins.int
        RESPONSE_HANDLING_FIELD_NUMBER: builtins.int
        @property
        def initialization_call(self) -> global___Snippet.ClientCall:
            """Client call configuration. Optional.
            This configures the call that initializes the stream.
            """
        client_stream_name: builtins.str
        """The name of the variable to capture the client stream in, i.e. the object
        in which streaming requests are written. Required.
        """
        @property
        def request_initialization(self) -> global___Snippet.StreamingRequestInitialization:
            """Describes how to initialize the streaming request objects. Required."""
        @property
        def response_handling(self) -> global___Snippet.SimpleResponseHandling:
            """Describes how to handle the response. Optional.
            Note that the response will be available after all the streaming requests
            have been written, each language should generate code accordingly.
            """
        def __init__(
            self,
            *,
            initialization_call: global___Snippet.ClientCall | None = ...,
            client_stream_name: builtins.str = ...,
            request_initialization: global___Snippet.StreamingRequestInitialization | None = ...,
            response_handling: global___Snippet.SimpleResponseHandling | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["initialization_call", b"initialization_call", "request_initialization", b"request_initialization", "response_handling", b"response_handling"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["client_stream_name", b"client_stream_name", "initialization_call", b"initialization_call", "request_initialization", b"request_initialization", "response_handling", b"response_handling"]) -> None: ...

    @typing_extensions.final
    class ServerStreaming(google.protobuf.message.Message):
        """A server streaming RPC operation."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        REQUEST_INITIALIZATION_FIELD_NUMBER: builtins.int
        INITIALIZATION_CALL_FIELD_NUMBER: builtins.int
        SERVER_STREAM_NAME_FIELD_NUMBER: builtins.int
        RESPONSE_HANDLING_FIELD_NUMBER: builtins.int
        @property
        def request_initialization(self) -> global___Snippet.SimpleRequestInitialization:
            """Describes how to initialize the request object. Required."""
        @property
        def initialization_call(self) -> global___Snippet.ClientCall:
            """Client call configuration. Optional."""
        server_stream_name: builtins.str
        """The name of the variable to capture the server stream in, i.e. the object
        from which streaming responses will be read. Optional if the stream is
        not to be read.
        """
        @property
        def response_handling(self) -> global___Snippet.StreamingResponseHandling:
            """Describes how to handle the streaming responses. Optional if the stream
            is not to be read.
            """
        def __init__(
            self,
            *,
            request_initialization: global___Snippet.SimpleRequestInitialization | None = ...,
            initialization_call: global___Snippet.ClientCall | None = ...,
            server_stream_name: builtins.str = ...,
            response_handling: global___Snippet.StreamingResponseHandling | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["initialization_call", b"initialization_call", "request_initialization", b"request_initialization", "response_handling", b"response_handling"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["initialization_call", b"initialization_call", "request_initialization", b"request_initialization", "response_handling", b"response_handling", "server_stream_name", b"server_stream_name"]) -> None: ...

    @typing_extensions.final
    class BidiStreaming(google.protobuf.message.Message):
        """A bidirectional streaming RPC operation."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        INITIALIZATION_CALL_FIELD_NUMBER: builtins.int
        CLIENT_STREAM_NAME_FIELD_NUMBER: builtins.int
        REQUEST_INITIALIZATION_FIELD_NUMBER: builtins.int
        SERVER_STREAM_NAME_FIELD_NUMBER: builtins.int
        RESPONSE_HANDLING_FIELD_NUMBER: builtins.int
        @property
        def initialization_call(self) -> global___Snippet.ClientCall:
            """Client call configuration. Optional.
            This configures the call that initializes de stream.
            """
        client_stream_name: builtins.str
        """The name of the variable to capture the client stream in, i.e. the object
        in which streaming requests are written. Required.
        """
        @property
        def request_initialization(self) -> global___Snippet.StreamingRequestInitialization:
            """Describes how to initialize the streaming request objects. Required."""
        server_stream_name: builtins.str
        """The name of the variable to capture the server stream in, i.e. the object
        from which streaming responses will be read. Optional if the stream is
        not to be read.
        """
        @property
        def response_handling(self) -> global___Snippet.StreamingResponseHandling:
            """Describes how to handle the streaming responses. Optional if the stream
            is not to be read.
            """
        def __init__(
            self,
            *,
            initialization_call: global___Snippet.ClientCall | None = ...,
            client_stream_name: builtins.str = ...,
            request_initialization: global___Snippet.StreamingRequestInitialization | None = ...,
            server_stream_name: builtins.str = ...,
            response_handling: global___Snippet.StreamingResponseHandling | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["initialization_call", b"initialization_call", "request_initialization", b"request_initialization", "response_handling", b"response_handling"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["client_stream_name", b"client_stream_name", "initialization_call", b"initialization_call", "request_initialization", b"request_initialization", "response_handling", b"response_handling", "server_stream_name", b"server_stream_name"]) -> None: ...

    @typing_extensions.final
    class ClientCall(google.protobuf.message.Message):
        """An actual client service call.
        Note: Just pre_call statements for now, but this message is included so
        that adding per call options later on is not a breaking change.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        PRE_CALL_FIELD_NUMBER: builtins.int
        @property
        def pre_call(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
            """Statements to be executed before the initial call to the service client
            method is made. Whether that results in an RPC call or not is operation
            type and language dependent. May be empty.
            If any, statements should appear in generated code in the same order as
            they appear on this field.
            """
        def __init__(
            self,
            *,
            pre_call: collections.abc.Iterable[global___Statement] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["pre_call", b"pre_call"]) -> None: ...

    @typing_extensions.final
    class SimpleRequestInitialization(google.protobuf.message.Message):
        """Describes how to initialize a simple request object."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        PRE_REQUEST_INITIALIZATION_FIELD_NUMBER: builtins.int
        REQUEST_VALUE_FIELD_NUMBER: builtins.int
        REQUEST_NAME_FIELD_NUMBER: builtins.int
        @property
        def pre_request_initialization(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
            """Statements to be executed before the request object is initialized. For
            instance, some Statement.Declaration statements of variables to be used
            in request initialization. May be empty. If any, statements will be
            executed in the same order as they appear on pre_request_initialization.
            """
        @property
        def request_value(self) -> global___Expression:
            """The request value. Required.
            Should resolve to a type that is assignable to the request type of the
            RPC.
            """
        request_name: builtins.str
        """The name for the variable that will hold the request object.
        For example "request". Required.
        """
        def __init__(
            self,
            *,
            pre_request_initialization: collections.abc.Iterable[global___Statement] | None = ...,
            request_value: global___Expression | None = ...,
            request_name: builtins.str = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["request_value", b"request_value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["pre_request_initialization", b"pre_request_initialization", "request_name", b"request_name", "request_value", b"request_value"]) -> None: ...

    @typing_extensions.final
    class StreamingRequestInitialization(google.protobuf.message.Message):
        """Describes how to make requests to client streaming RPCs.
        An iteration is defined which makes some per-iteration
        Expression.NameValue availables that may be used to define
        streaming_request.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        FIRST_STREAMING_REQUEST_FIELD_NUMBER: builtins.int
        ITERATION_FIELD_NUMBER: builtins.int
        STREAMING_REQUEST_FIELD_NUMBER: builtins.int
        @property
        def first_streaming_request(self) -> global___Snippet.SimpleRequestInitialization:
            """Describes how to initialize the first streaming request. Optional for
            operations that do not require a specific first request.
            """
        @property
        def iteration(self) -> global___Statement.Iteration:
            """The iteration to use for defining the streaming requests. Required."""
        @property
        def streaming_request(self) -> global___Snippet.SimpleRequestInitialization:
            """The streaming request that may be defined with iteration-specific
            variables, and will result in a sequence of requests. Required.
            Initialization of streaming_request should be placed, in generated code,
            on the inner-most iteration defined by the iteration field as iterations
            may be nested.
            """
        def __init__(
            self,
            *,
            first_streaming_request: global___Snippet.SimpleRequestInitialization | None = ...,
            iteration: global___Statement.Iteration | None = ...,
            streaming_request: global___Snippet.SimpleRequestInitialization | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["first_streaming_request", b"first_streaming_request", "iteration", b"iteration", "streaming_request", b"streaming_request"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["first_streaming_request", b"first_streaming_request", "iteration", b"iteration", "streaming_request", b"streaming_request"]) -> None: ...

    @typing_extensions.final
    class SimpleResponseHandling(google.protobuf.message.Message):
        """Describes how to handle a simple response object."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESPONSE_NAME_FIELD_NUMBER: builtins.int
        response_name: builtins.str
        """The name of the variable to capture the response in. May be unset if
        the RPC does not return anything or the response is not to be captured.
        """
        def __init__(
            self,
            *,
            response_name: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["response_name", b"response_name"]) -> None: ...

    @typing_extensions.final
    class PaginatedResponseHandling(google.protobuf.message.Message):
        """Describes how to handle paginated responses."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing_extensions.final
        class ByItem(google.protobuf.message.Message):
            """Iterate item by item, lazily and automatically fetching pages as needed."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            ITEM_NAME_FIELD_NUMBER: builtins.int
            PER_ITEM_STATEMENTS_FIELD_NUMBER: builtins.int
            item_name: builtins.str
            """The name of the variable to capture the current item in. Required."""
            @property
            def per_item_statements(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
                """Statements to execute for each item. Optional."""
            def __init__(
                self,
                *,
                item_name: builtins.str = ...,
                per_item_statements: collections.abc.Iterable[global___Statement] | None = ...,
            ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["item_name", b"item_name", "per_item_statements", b"per_item_statements"]) -> None: ...

        @typing_extensions.final
        class ByPage(google.protobuf.message.Message):
            """Iterate page by page, lazily and automatically fetching pages as needed."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            PAGE_NAME_FIELD_NUMBER: builtins.int
            PER_PAGE_STATEMENTS_FIELD_NUMBER: builtins.int
            BY_ITEM_FIELD_NUMBER: builtins.int
            page_name: builtins.str
            """The name of the variable to capture the current page in. Required."""
            @property
            def per_page_statements(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
                """Statements to execute for each page. Optional."""
            @property
            def by_item(self) -> global___Snippet.PaginatedResponseHandling.ByItem:
                """By item iteration configuration within the current page. Optional."""
            def __init__(
                self,
                *,
                page_name: builtins.str = ...,
                per_page_statements: collections.abc.Iterable[global___Statement] | None = ...,
                by_item: global___Snippet.PaginatedResponseHandling.ByItem | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["by_item", b"by_item"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["by_item", b"by_item", "page_name", b"page_name", "per_page_statements", b"per_page_statements"]) -> None: ...

        @typing_extensions.final
        class NextPageToken(google.protobuf.message.Message):
            """Iterate page by page, explicitly using the next page token.
            This pagination mode will modify the original request by subsequently
            setting the next page token obtained from the previous response.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            NEXT_PAGE_TOKEN_NAME_FIELD_NUMBER: builtins.int
            EXPLICIT_PAGE_SIZE_FIELD_NUMBER: builtins.int
            BY_PAGE_FIELD_NUMBER: builtins.int
            next_page_token_name: builtins.str
            """The name of the variable to capture the next page token in. Required."""
            @property
            def explicit_page_size(self) -> global___Expression:
                """The explicit and guaranteed page size for fetched pages. Required.
                TODO: Double check that all languages have this modality.
                Otherwise, they may fallback to by page iteration.
                """
            @property
            def by_page(self) -> global___Snippet.PaginatedResponseHandling.ByPage:
                """Configures how to iterate over the explicitly fetched page."""
            def __init__(
                self,
                *,
                next_page_token_name: builtins.str = ...,
                explicit_page_size: global___Expression | None = ...,
                by_page: global___Snippet.PaginatedResponseHandling.ByPage | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["by_page", b"by_page", "explicit_page_size", b"explicit_page_size"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["by_page", b"by_page", "explicit_page_size", b"explicit_page_size", "next_page_token_name", b"next_page_token_name"]) -> None: ...

        RESPONSE_NAME_FIELD_NUMBER: builtins.int
        BY_ITEM_FIELD_NUMBER: builtins.int
        BY_PAGE_FIELD_NUMBER: builtins.int
        NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
        response_name: builtins.str
        """The name of the variable to capture the initial client call response in.
        Required. Note that this will capture the object representing the lazy
        item sequence.
        """
        @property
        def by_item(self) -> global___Snippet.PaginatedResponseHandling.ByItem:
            """Iterate item by item, lazily and automatically fetching pages as
            needed.
            """
        @property
        def by_page(self) -> global___Snippet.PaginatedResponseHandling.ByPage:
            """Iterate page by page, lazily and automatically fetching pages as
            needed.
            """
        @property
        def next_page_token(self) -> global___Snippet.PaginatedResponseHandling.NextPageToken:
            """Iterate page by page, explicitly using the next page token.
            This pagination mode will modify the original request by subsequently
            setting the next page token obtained from the previous response.
            """
        def __init__(
            self,
            *,
            response_name: builtins.str = ...,
            by_item: global___Snippet.PaginatedResponseHandling.ByItem | None = ...,
            by_page: global___Snippet.PaginatedResponseHandling.ByPage | None = ...,
            next_page_token: global___Snippet.PaginatedResponseHandling.NextPageToken | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["by_item", b"by_item", "by_page", b"by_page", "next_page_token", b"next_page_token", "pagination_kind", b"pagination_kind"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["by_item", b"by_item", "by_page", b"by_page", "next_page_token", b"next_page_token", "pagination_kind", b"pagination_kind", "response_name", b"response_name"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["pagination_kind", b"pagination_kind"]) -> typing_extensions.Literal["by_item", "by_page", "next_page_token"] | None: ...

    @typing_extensions.final
    class LroResponseHandling(google.protobuf.message.Message):
        """Describes how to handle LRO responses."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _PollingType:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _PollingTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Snippet.LroResponseHandling._PollingType.ValueType], builtins.type):  # noqa: F821
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNTIL_COMPLETION: Snippet.LroResponseHandling._PollingType.ValueType  # 0
            """Poll until completion. Default value."""
            ONCE: Snippet.LroResponseHandling._PollingType.ValueType  # 1
            """Poll just once."""
            NONE: Snippet.LroResponseHandling._PollingType.ValueType  # 2
            """Do not poll."""

        class PollingType(_PollingType, metaclass=_PollingTypeEnumTypeWrapper): ...
        UNTIL_COMPLETION: Snippet.LroResponseHandling.PollingType.ValueType  # 0
        """Poll until completion. Default value."""
        ONCE: Snippet.LroResponseHandling.PollingType.ValueType  # 1
        """Poll just once."""
        NONE: Snippet.LroResponseHandling.PollingType.ValueType  # 2
        """Do not poll."""

        RESPONSE_NAME_FIELD_NUMBER: builtins.int
        POLLING_TYPE_FIELD_NUMBER: builtins.int
        POLLING_RESPONSE_NAME_FIELD_NUMBER: builtins.int
        POLLING_CALL_FIELD_NUMBER: builtins.int
        response_name: builtins.str
        """The name of the variable to capture the LRO response in. Required.
        This will capture the response to the LRO operaion call and not to
        polling operations.
        """
        polling_type: global___Snippet.LroResponseHandling.PollingType.ValueType
        """How to perform polling. Required."""
        polling_response_name: builtins.str
        """The name of the variable to capture the polling response in. Optional if
        the polling result should not be captured. Should be unset if
        PollingType.NONE is specified.
        """
        @property
        def polling_call(self) -> global___Snippet.ClientCall:
            """Configures the polling call. Optional. Should be unset if
            PollingType.NONE is specified.
            """
        def __init__(
            self,
            *,
            response_name: builtins.str = ...,
            polling_type: global___Snippet.LroResponseHandling.PollingType.ValueType = ...,
            polling_response_name: builtins.str = ...,
            polling_call: global___Snippet.ClientCall | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["polling_call", b"polling_call"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["polling_call", b"polling_call", "polling_response_name", b"polling_response_name", "polling_type", b"polling_type", "response_name", b"response_name"]) -> None: ...

    @typing_extensions.final
    class StreamingResponseHandling(google.protobuf.message.Message):
        """Describes how to handle streaming responses."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        CURRENT_RESPONSE_NAME_FIELD_NUMBER: builtins.int
        PER_STREAM_RESPONSE_STATEMENTS_FIELD_NUMBER: builtins.int
        current_response_name: builtins.str
        """The name of the variable to capture the current response in the stream.
        Required.
        """
        @property
        def per_stream_response_statements(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
            """Statements to execute for each stream response. Optional."""
        def __init__(
            self,
            *,
            current_response_name: builtins.str = ...,
            per_stream_response_statements: collections.abc.Iterable[global___Statement] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["current_response_name", b"current_response_name", "per_stream_response_statements", b"per_stream_response_statements"]) -> None: ...

    SERVICE_CLIENT_INITIALIZATION_FIELD_NUMBER: builtins.int
    STANDARD_FIELD_NUMBER: builtins.int
    PAGINATED_FIELD_NUMBER: builtins.int
    LRO_FIELD_NUMBER: builtins.int
    CLIENT_STREAMING_FIELD_NUMBER: builtins.int
    SERVER_STREAMING_FIELD_NUMBER: builtins.int
    BIDI_STREAMING_FIELD_NUMBER: builtins.int
    FINAL_STATEMENTS_FIELD_NUMBER: builtins.int
    @property
    def service_client_initialization(self) -> global___Snippet.ClientInitialization:
        """Service client initialization. Optional. If unset language-specific
        defaults will be applied.
        """
    @property
    def standard(self) -> global___Snippet.Standard:
        """A standard RPC operation."""
    @property
    def paginated(self) -> global___Snippet.Paginated:
        """A paginated RPC operation."""
    @property
    def lro(self) -> global___Snippet.Lro:
        """A long-running RPC operation."""
    @property
    def client_streaming(self) -> global___Snippet.ClientStreaming:
        """A client streaming RPC operation."""
    @property
    def server_streaming(self) -> global___Snippet.ServerStreaming:
        """A server streaming RPC operation."""
    @property
    def bidi_streaming(self) -> global___Snippet.BidiStreaming:
        """A bidirectional streaming RPC operation."""
    @property
    def final_statements(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
        """Statements to be executed before the snippet ends. For instance, some
        Statement.StandardOutput statements and the Statement.Return statement.
        May be empty. If any, statements should appear on generated code in the
        same order as they appear on this field.
        """
    def __init__(
        self,
        *,
        service_client_initialization: global___Snippet.ClientInitialization | None = ...,
        standard: global___Snippet.Standard | None = ...,
        paginated: global___Snippet.Paginated | None = ...,
        lro: global___Snippet.Lro | None = ...,
        client_streaming: global___Snippet.ClientStreaming | None = ...,
        server_streaming: global___Snippet.ServerStreaming | None = ...,
        bidi_streaming: global___Snippet.BidiStreaming | None = ...,
        final_statements: collections.abc.Iterable[global___Statement] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bidi_streaming", b"bidi_streaming", "call", b"call", "client_streaming", b"client_streaming", "lro", b"lro", "paginated", b"paginated", "server_streaming", b"server_streaming", "service_client_initialization", b"service_client_initialization", "standard", b"standard"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bidi_streaming", b"bidi_streaming", "call", b"call", "client_streaming", b"client_streaming", "final_statements", b"final_statements", "lro", b"lro", "paginated", b"paginated", "server_streaming", b"server_streaming", "service_client_initialization", b"service_client_initialization", "standard", b"standard"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["call", b"call"]) -> typing_extensions.Literal["standard", "paginated", "lro", "client_streaming", "server_streaming", "bidi_streaming"] | None: ...

global___Snippet = Snippet

@typing_extensions.final
class Statement(google.protobuf.message.Message):
    """A stament that will translate into equivalent language-specific statements."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class Declaration(google.protobuf.message.Message):
        """A declaration which may be used for parameters or variables.
        Note that the only form of assignment supported is on declaration.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TYPE_FIELD_NUMBER: builtins.int
        NAME_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        @property
        def type(self) -> global___Type:
            """The type of this declaration. Required unless the snippet is to be
            generated in non-statically typed languages only.
            """
        name: builtins.str
        """The name of the variable or parameter. Required."""
        @property
        def value(self) -> global___Expression:
            """The value to assign to the variable or parameter.
            Optional for parameters.
            Required for variables as assignment outside of a declaration is not
            supported.
            Should resolve to a type that is assignable to this Declaration type.
            """
        description: builtins.str
        """An optional description that will be included alongside the declaration
        likely as a code comment.
        """
        def __init__(
            self,
            *,
            type: global___Type | None = ...,
            name: builtins.str = ...,
            value: global___Expression | None = ...,
            description: builtins.str = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["type", b"type", "value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["description", b"description", "name", b"name", "type", b"type", "value", b"value"]) -> None: ...

    @typing_extensions.final
    class StandardOutput(google.protobuf.message.Message):
        """A statement to write information to sdtout."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        VALUE_FIELD_NUMBER: builtins.int
        @property
        def value(self) -> global___Expression:
            """The value to write to sdtout.
            Should evaluate to a string value or resolve to a type that all languages
            are able to convert to string without specific code, for instance numeric
            values, and possibly protobuf messages as they may be converted to their
            JSON representation.
            """
        def __init__(
            self,
            *,
            value: global___Expression | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["value", b"value"]) -> None: ...

    @typing_extensions.final
    class Return(google.protobuf.message.Message):
        """A return statement."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESULT_FIELD_NUMBER: builtins.int
        @property
        def result(self) -> global___Expression:
            """The value to return. Should resolve to a type that is assignable to
            SnippetSignature.return_type.
            """
        def __init__(
            self,
            *,
            result: global___Expression | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["result", b"result"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["result", b"result"]) -> None: ...

    @typing_extensions.final
    class Conditional(google.protobuf.message.Message):
        """A conditional statement. One of two given sets of statements will be
        executed depending on the result of evaluating a given condition.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        CONDITION_FIELD_NUMBER: builtins.int
        ON_TRUE_FIELD_NUMBER: builtins.int
        ON_FALSE_FIELD_NUMBER: builtins.int
        @property
        def condition(self) -> global___Expression:
            """The condition to evaluate. Should evaluate to a bolean value."""
        @property
        def on_true(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
            """The set of statements to execute if condition evaluates to true.
            The statements should be executed in the order that they appear.
            """
        @property
        def on_false(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
            """The set of statements to execute if condition evaluates to false.
            The statements should be executed in the order that they appear.
            """
        def __init__(
            self,
            *,
            condition: global___Expression | None = ...,
            on_true: collections.abc.Iterable[global___Statement] | None = ...,
            on_false: collections.abc.Iterable[global___Statement] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["condition", b"condition"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["condition", b"condition", "on_false", b"on_false", "on_true", b"on_true"]) -> None: ...

    @typing_extensions.final
    class Iteration(google.protobuf.message.Message):
        """An iteration statement. A given Statement set will be executed
        repeatedly according to the iteration definition.
        Each iteration type will make a per-step Expression.NameValue set
        available that may be used withing the given Statement set.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing_extensions.final
        class NumericSequenceIteration(google.protobuf.message.Message):
            """Represents a numeric sequence iteration.
            A numeric sequence is defined over which to iterate making the current
            element of the sequence available in a variable.
            It's ultimately the responsability of the user to define a finite
            sequence, although tooling may be provided to help.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            START_AT_FIELD_NUMBER: builtins.int
            INCREMENT_FIELD_NUMBER: builtins.int
            MULTIPLIER_FIELD_NUMBER: builtins.int
            LESS_THAN_OR_EQUAL_FIELD_NUMBER: builtins.int
            LESS_THAN_FIELD_NUMBER: builtins.int
            GREATER_THAN_OR_EQUAL_FIELD_NUMBER: builtins.int
            GREATER_THAN_FIELD_NUMBER: builtins.int
            TOTAL_STEPS_FIELD_NUMBER: builtins.int
            @property
            def start_at(self) -> global___Statement.Declaration:
                """Where to start the sequence at, ie. the first element of the iteration.
                Required.
                The Statement.Declaration.type should be a numeric type.
                The Statement.Declaration.value is required.
                The Statement.Declaration.name will be the name used to make the
                current element of the iteration available.
                """
            @property
            def increment(self) -> global___Expression:
                """An increment, which may be a positive or negative value.
                Should resolve to a numeric type.
                """
            @property
            def multiplier(self) -> global___Expression:
                """A multiplier, which may be less than or greater than 1.
                Should resolve to a numeric type.
                """
            @property
            def less_than_or_equal(self) -> global___Expression:
                """When the current value is less than or equal to this value.
                Should resolve to a numeric type.
                """
            @property
            def less_than(self) -> global___Expression:
                """When the current value is less than this value.
                Should resolve to a numeric type.
                """
            @property
            def greater_than_or_equal(self) -> global___Expression:
                """When the current value is greater than or equal to this value.
                Should resolve to a numeric type.
                """
            @property
            def greater_than(self) -> global___Expression:
                """When the current value is greater than this value.
                Should resolve to a numeric type.
                """
            @property
            def total_steps(self) -> global___Expression:
                """After a set number of steps. Must be non-negative.
                Should resolve to an integer type.
                """
            def __init__(
                self,
                *,
                start_at: global___Statement.Declaration | None = ...,
                increment: global___Expression | None = ...,
                multiplier: global___Expression | None = ...,
                less_than_or_equal: global___Expression | None = ...,
                less_than: global___Expression | None = ...,
                greater_than_or_equal: global___Expression | None = ...,
                greater_than: global___Expression | None = ...,
                total_steps: global___Expression | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["end", b"end", "greater_than", b"greater_than", "greater_than_or_equal", b"greater_than_or_equal", "increment", b"increment", "less_than", b"less_than", "less_than_or_equal", b"less_than_or_equal", "multiplier", b"multiplier", "start_at", b"start_at", "step", b"step", "total_steps", b"total_steps"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["end", b"end", "greater_than", b"greater_than", "greater_than_or_equal", b"greater_than_or_equal", "increment", b"increment", "less_than", b"less_than", "less_than_or_equal", b"less_than_or_equal", "multiplier", b"multiplier", "start_at", b"start_at", "step", b"step", "total_steps", b"total_steps"]) -> None: ...
            @typing.overload
            def WhichOneof(self, oneof_group: typing_extensions.Literal["end", b"end"]) -> typing_extensions.Literal["less_than_or_equal", "less_than", "greater_than_or_equal", "greater_than", "total_steps"] | None: ...
            @typing.overload
            def WhichOneof(self, oneof_group: typing_extensions.Literal["step", b"step"]) -> typing_extensions.Literal["increment", "multiplier"] | None: ...

        @typing_extensions.final
        class RepeatedIteration(google.protobuf.message.Message):
            """Represents an iteration over repeated elements.
            A repeated value is provided over which the iteration will occur making
            the current element of the sequence available in a variable.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            REPEATED_ELEMENTS_FIELD_NUMBER: builtins.int
            CURRENT_NAME_FIELD_NUMBER: builtins.int
            @property
            def repeated_elements(self) -> global___Statement.Declaration:
                """The repeated elements to iterate over. Required.
                The Statement.Declaration.type should be Type.RepeatedType.
                The Statement.Declaration.value is required.
                TODO: Consider this to be a oneof Declaration or Expression.NameValue.
                """
            current_name: builtins.str
            """The name of the variable that will hold the value of the current
            element on each iteration. For example "item". Required. The type of
            this variable will be the same as that of the elements in
            repeated_elements.
            """
            def __init__(
                self,
                *,
                repeated_elements: global___Statement.Declaration | None = ...,
                current_name: builtins.str = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["repeated_elements", b"repeated_elements"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["current_name", b"current_name", "repeated_elements", b"repeated_elements"]) -> None: ...

        @typing_extensions.final
        class MapIteration(google.protobuf.message.Message):
            """Represents an iteration over a map.
            A map value is provided over which the iteration will occur making
            the current key and element of the map availables in variables.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            MAP_FIELD_NUMBER: builtins.int
            CURRENT_KEY_NAME_FIELD_NUMBER: builtins.int
            CURRENT_VALUE_NAME_FIELD_NUMBER: builtins.int
            @property
            def map(self) -> global___Statement.Declaration:
                """The map to iterate over. Required.
                The Statement.Declaration.type should be Type.MapType.
                The Statement.Declaration.value is required.
                TODO: Consider this to be a oneof Declaration or Expression.NameValue.
                """
            current_key_name: builtins.str
            """The name of the variable that will hold the value of the current key
            on each iteration. For example "key". Required.
            The type of this variable will be the same as that of the keys in map.
            """
            current_value_name: builtins.str
            """The name of the variable that will hold the value associated to the
            current key on each iteration. For example "value". Required.
            The type of this variable will be the same as that of the values in
            map.
            """
            def __init__(
                self,
                *,
                map: global___Statement.Declaration | None = ...,
                current_key_name: builtins.str = ...,
                current_value_name: builtins.str = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["map", b"map"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["current_key_name", b"current_key_name", "current_value_name", b"current_value_name", "map", b"map"]) -> None: ...

        @typing_extensions.final
        class BytesIteration(google.protobuf.message.Message):
            """Represents an iteration over a byte sequence.
            A byte sequence is provided over which the iteration will occur making
            the current chunk of bytes available in a variable.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            BYTE_SEQUENCE_FIELD_NUMBER: builtins.int
            CHUNK_SIZE_FIELD_NUMBER: builtins.int
            TOTAL_CHUNKS_FIELD_NUMBER: builtins.int
            CHUNK_TYPE_FIELD_NUMBER: builtins.int
            CURRENT_NAME_FIELD_NUMBER: builtins.int
            @property
            def byte_sequence(self) -> global___Statement.Declaration:
                """The byte sequence to iterate over. Required.
                The Statement.Declaration.type should be Type.BytesType.
                The Statement.Declaration.value is required.
                """
            @property
            def chunk_size(self) -> global___Expression:
                """The size of the chuncks to split the byte sequence in. The last chunk
                will be at most chunk_size. Must be positive.
                Should resolve to an integer type.
                """
            @property
            def total_chunks(self) -> global___Expression:
                """The total amount of chunks to split the byte sequence into. Note that
                this is only possible when the byte sequence has a known length so it
                might not be possible with certain streams, for instance, with
                network streams. Must be positive.
                Should resolve to an integer type.
                """
            @property
            def chunk_type(self) -> global___Type.BytesType:
                """The type in which the chunk will be made available."""
            current_name: builtins.str
            """The name of the variable that will hold the value of the current chunk
            on each iteration. For example "chunk". Required.
            Will be of type chunk_type.
            """
            def __init__(
                self,
                *,
                byte_sequence: global___Statement.Declaration | None = ...,
                chunk_size: global___Expression | None = ...,
                total_chunks: global___Expression | None = ...,
                chunk_type: global___Type.BytesType | None = ...,
                current_name: builtins.str = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["byte_sequence", b"byte_sequence", "chunk", b"chunk", "chunk_size", b"chunk_size", "chunk_type", b"chunk_type", "total_chunks", b"total_chunks"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["byte_sequence", b"byte_sequence", "chunk", b"chunk", "chunk_size", b"chunk_size", "chunk_type", b"chunk_type", "current_name", b"current_name", "total_chunks", b"total_chunks"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["chunk", b"chunk"]) -> typing_extensions.Literal["chunk_size", "total_chunks"] | None: ...

        NUMERIC_SEQUENCE_ITERATION_FIELD_NUMBER: builtins.int
        REPEATED_ITERATION_FIELD_NUMBER: builtins.int
        MAP_ITERATION_FIELD_NUMBER: builtins.int
        BYTES_ITERATION_FIELD_NUMBER: builtins.int
        STATEMENTS_FIELD_NUMBER: builtins.int
        @property
        def numeric_sequence_iteration(self) -> global___Statement.Iteration.NumericSequenceIteration:
            """A numeric sequence iteration."""
        @property
        def repeated_iteration(self) -> global___Statement.Iteration.RepeatedIteration:
            """An iteration over repeated elements, i.e. an iteration over a list."""
        @property
        def map_iteration(self) -> global___Statement.Iteration.MapIteration:
            """A map iteration."""
        @property
        def bytes_iteration(self) -> global___Statement.Iteration.BytesIteration:
            """A bytes sequence iteration."""
        @property
        def statements(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Statement]:
            """The set of statements to execute on each step of the iteration.
            The statements should be executed in the order that they appear.
            May be empty as iterations will also be used for streaming request
            initialization or streaming response handling.
            """
        def __init__(
            self,
            *,
            numeric_sequence_iteration: global___Statement.Iteration.NumericSequenceIteration | None = ...,
            repeated_iteration: global___Statement.Iteration.RepeatedIteration | None = ...,
            map_iteration: global___Statement.Iteration.MapIteration | None = ...,
            bytes_iteration: global___Statement.Iteration.BytesIteration | None = ...,
            statements: collections.abc.Iterable[global___Statement] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["bytes_iteration", b"bytes_iteration", "iteration_type", b"iteration_type", "map_iteration", b"map_iteration", "numeric_sequence_iteration", b"numeric_sequence_iteration", "repeated_iteration", b"repeated_iteration"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["bytes_iteration", b"bytes_iteration", "iteration_type", b"iteration_type", "map_iteration", b"map_iteration", "numeric_sequence_iteration", b"numeric_sequence_iteration", "repeated_iteration", b"repeated_iteration", "statements", b"statements"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["iteration_type", b"iteration_type"]) -> typing_extensions.Literal["numeric_sequence_iteration", "repeated_iteration", "map_iteration", "bytes_iteration"] | None: ...

    DECLARATION_FIELD_NUMBER: builtins.int
    STANDARD_OUTPUT_FIELD_NUMBER: builtins.int
    RETURN_FIELD_NUMBER: builtins.int
    CONDITIONAL_FIELD_NUMBER: builtins.int
    ITERATION_FIELD_NUMBER: builtins.int
    @property
    def declaration(self) -> global___Statement.Declaration:
        """A declaration which may be used for parameters or variables. Note that
        the only form of assignment supported is on declaration.
        Note that a declaration has scope depending on whether it's included as
        a top level statement in any of the snippet sections or is a nested
        statement.
        """
    @property
    def standard_output(self) -> global___Statement.StandardOutput:
        """A statement to write information to sdtout."""
    @property
    def conditional(self) -> global___Statement.Conditional:
        """A conditional statement. One of two given sets of statements will be
        executed depending on the result of evaluating a given condition.
        """
    @property
    def iteration(self) -> global___Statement.Iteration:
        """An iteration statement. A given Statement set will be executed
        repeatedly according to the iteration definition.
        Each iteration type will make a per-step Expression.NameValue set
        available that may be used withing the given Statement set.
        """
    def __init__(
        self,
        *,
        declaration: global___Statement.Declaration | None = ...,
        standard_output: global___Statement.StandardOutput | None = ...,
        conditional: global___Statement.Conditional | None = ...,
        iteration: global___Statement.Iteration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["conditional", b"conditional", "declaration", b"declaration", "iteration", b"iteration", "return", b"return", "standard_output", b"standard_output", "statement_type", b"statement_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["conditional", b"conditional", "declaration", b"declaration", "iteration", b"iteration", "return", b"return", "standard_output", b"standard_output", "statement_type", b"statement_type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["statement_type", b"statement_type"]) -> typing_extensions.Literal["declaration", "standard_output", "return", "conditional", "iteration"] | None: ...

global___Statement = Statement

@typing_extensions.final
class Type(google.protobuf.message.Message):
    """Represents type of values. To be used, for instance, for
    Statement.Declaration or for specifying the return type of the snippet.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ScalarType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ScalarTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Type._ScalarType.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SCALAR_TYPE_UNDEFINED: Type._ScalarType.ValueType  # 0
        """The scalar type has not been specified. Consumers should not see this
        value.
        """
        TYPE_DOUBLE: Type._ScalarType.ValueType  # 1
        TYPE_FLOAT: Type._ScalarType.ValueType  # 2
        TYPE_INT64: Type._ScalarType.ValueType  # 3
        TYPE_UINT64: Type._ScalarType.ValueType  # 4
        TYPE_INT32: Type._ScalarType.ValueType  # 5
        TYPE_FIXED64: Type._ScalarType.ValueType  # 6
        TYPE_FIXED32: Type._ScalarType.ValueType  # 7
        TYPE_BOOL: Type._ScalarType.ValueType  # 8
        TYPE_STRING: Type._ScalarType.ValueType  # 9
        TYPE_UINT32: Type._ScalarType.ValueType  # 13
        TYPE_SFIXED32: Type._ScalarType.ValueType  # 15
        TYPE_SFIXED64: Type._ScalarType.ValueType  # 16
        TYPE_SINT32: Type._ScalarType.ValueType  # 17
        TYPE_SINT64: Type._ScalarType.ValueType  # 18

    class ScalarType(_ScalarType, metaclass=_ScalarTypeEnumTypeWrapper):
        """Represents protobuf scalar types that should be translated to the usual
        language-specific types.
        https://developers.google.com/protocol-buffers/docs/proto3#scalar
        This could have been FieldDescriptorProto.Type except that proto2 enums
        cannot be used in proto3. Also, a few of the types in
        FieldDescriptorsProto.Type are individually supported in SnippetGen Config.
        Values allowed for this type are:
        - Expression.default_value,
        - Expression.name_value as long as the identifier resolves to a type that
          is assignable to this one.
        - Expression.number_value for the numeric FieldDescriptorProto.Type(s).
        - Expression.boolean_value for FieldDescriptorProto.Type.TYPE_BOOL.
        - Expression.string_value for FieldDescriptorProto.Type.TYPE_STRING.
        - Any other value that resolves to a type that is assignable to this one.
        """

    SCALAR_TYPE_UNDEFINED: Type.ScalarType.ValueType  # 0
    """The scalar type has not been specified. Consumers should not see this
    value.
    """
    TYPE_DOUBLE: Type.ScalarType.ValueType  # 1
    TYPE_FLOAT: Type.ScalarType.ValueType  # 2
    TYPE_INT64: Type.ScalarType.ValueType  # 3
    TYPE_UINT64: Type.ScalarType.ValueType  # 4
    TYPE_INT32: Type.ScalarType.ValueType  # 5
    TYPE_FIXED64: Type.ScalarType.ValueType  # 6
    TYPE_FIXED32: Type.ScalarType.ValueType  # 7
    TYPE_BOOL: Type.ScalarType.ValueType  # 8
    TYPE_STRING: Type.ScalarType.ValueType  # 9
    TYPE_UINT32: Type.ScalarType.ValueType  # 13
    TYPE_SFIXED32: Type.ScalarType.ValueType  # 15
    TYPE_SFIXED64: Type.ScalarType.ValueType  # 16
    TYPE_SINT32: Type.ScalarType.ValueType  # 17
    TYPE_SINT64: Type.ScalarType.ValueType  # 18

    @typing_extensions.final
    class EnumType(google.protobuf.message.Message):
        """Represents protobuf enum types. These should be known by the
        microgenerators on generation time, so they'll probably be enums defined
        within the API being generated or one of its mixins.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENUM_FULL_NAME_FIELD_NUMBER: builtins.int
        enum_full_name: builtins.str
        """The protobuf full enum name, including the protobuf package."""
        def __init__(
            self,
            *,
            enum_full_name: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["enum_full_name", b"enum_full_name"]) -> None: ...

    @typing_extensions.final
    class BytesType(google.protobuf.message.Message):
        """Represents a bytes type."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _LanguageEquivalent:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _LanguageEquivalentEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Type.BytesType._LanguageEquivalent.ValueType], builtins.type):  # noqa: F821
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            PROTOBUF_BYTES: Type.BytesType._LanguageEquivalent.ValueType  # 0
            """The same type used for representing protobuf bytes fields."""
            BASE64: Type.BytesType._LanguageEquivalent.ValueType  # 1
            """Language-specific string type, whose value will be understood as a
            base64 string representation of the bytes.
            """
            BYTE_ARRAY: Type.BytesType._LanguageEquivalent.ValueType  # 2
            """Language-specific byte array type."""
            STREAM: Type.BytesType._LanguageEquivalent.ValueType  # 3
            """Language-specific stream type."""

        class LanguageEquivalent(_LanguageEquivalent, metaclass=_LanguageEquivalentEnumTypeWrapper):
            """Possible language-specific equivalents to a bytes type."""

        PROTOBUF_BYTES: Type.BytesType.LanguageEquivalent.ValueType  # 0
        """The same type used for representing protobuf bytes fields."""
        BASE64: Type.BytesType.LanguageEquivalent.ValueType  # 1
        """Language-specific string type, whose value will be understood as a
        base64 string representation of the bytes.
        """
        BYTE_ARRAY: Type.BytesType.LanguageEquivalent.ValueType  # 2
        """Language-specific byte array type."""
        STREAM: Type.BytesType.LanguageEquivalent.ValueType  # 3
        """Language-specific stream type."""

        LANGUAGE_EQUIVALENT_FIELD_NUMBER: builtins.int
        language_equivalent: global___Type.BytesType.LanguageEquivalent.ValueType
        """The language-specific type that this bytes type should be generated as."""
        def __init__(
            self,
            *,
            language_equivalent: global___Type.BytesType.LanguageEquivalent.ValueType = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["language_equivalent", b"language_equivalent"]) -> None: ...

    @typing_extensions.final
    class MessageType(google.protobuf.message.Message):
        """Represents protobuf message types. These should be known by the
        microgenerators at generation time, so they'll usually be well known types,
        messaged defined within the API being generated or one of its mixins.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        MESSAGE_FULL_NAME_FIELD_NUMBER: builtins.int
        message_full_name: builtins.str
        """The protobuf full message name, including the protobuf package."""
        def __init__(
            self,
            *,
            message_full_name: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["message_full_name", b"message_full_name"]) -> None: ...

    @typing_extensions.final
    class RepeatedType(google.protobuf.message.Message):
        """Represents a repeated type."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _LanguageEquivalent:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _LanguageEquivalentEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Type.RepeatedType._LanguageEquivalent.ValueType], builtins.type):  # noqa: F821
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            PROTOBUF_REPEATED: Type.RepeatedType._LanguageEquivalent.ValueType  # 0
            """The same type used for representing protobuf repeated fields."""
            ARRAY: Type.RepeatedType._LanguageEquivalent.ValueType  # 1
            """Language-specific array type."""
            LIST: Type.RepeatedType._LanguageEquivalent.ValueType  # 2
            """Language-specific list type."""

        class LanguageEquivalent(_LanguageEquivalent, metaclass=_LanguageEquivalentEnumTypeWrapper):
            """Possible language-specific equivalents to a repeated type."""

        PROTOBUF_REPEATED: Type.RepeatedType.LanguageEquivalent.ValueType  # 0
        """The same type used for representing protobuf repeated fields."""
        ARRAY: Type.RepeatedType.LanguageEquivalent.ValueType  # 1
        """Language-specific array type."""
        LIST: Type.RepeatedType.LanguageEquivalent.ValueType  # 2
        """Language-specific list type."""

        ELEMENT_TYPE_FIELD_NUMBER: builtins.int
        LANGUAGE_EQUIVALENT_FIELD_NUMBER: builtins.int
        @property
        def element_type(self) -> global___Type:
            """The type of the elements."""
        language_equivalent: global___Type.RepeatedType.LanguageEquivalent.ValueType
        """The language-specific type that this repeated type should be generated
        as.
        """
        def __init__(
            self,
            *,
            element_type: global___Type | None = ...,
            language_equivalent: global___Type.RepeatedType.LanguageEquivalent.ValueType = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["element_type", b"element_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["element_type", b"element_type", "language_equivalent", b"language_equivalent"]) -> None: ...

    @typing_extensions.final
    class MapType(google.protobuf.message.Message):
        """Represents a map type."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _LanguageEquivalent:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _LanguageEquivalentEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Type.MapType._LanguageEquivalent.ValueType], builtins.type):  # noqa: F821
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            PROTOBUF_MAP: Type.MapType._LanguageEquivalent.ValueType  # 0
            """The same type used for representing protobuf map fields."""
            DICTIONARY: Type.MapType._LanguageEquivalent.ValueType  # 1
            """Language-specific dictionary or map type."""

        class LanguageEquivalent(_LanguageEquivalent, metaclass=_LanguageEquivalentEnumTypeWrapper):
            """Possible language-specific equivalents to a map type."""

        PROTOBUF_MAP: Type.MapType.LanguageEquivalent.ValueType  # 0
        """The same type used for representing protobuf map fields."""
        DICTIONARY: Type.MapType.LanguageEquivalent.ValueType  # 1
        """Language-specific dictionary or map type."""

        KEY_TYPE_FIELD_NUMBER: builtins.int
        VALUE_TYPE_FIELD_NUMBER: builtins.int
        LANGUAGE_EQUIVALENT_FIELD_NUMBER: builtins.int
        @property
        def key_type(self) -> global___Type:
            """The type of the keys."""
        @property
        def value_type(self) -> global___Type:
            """The type of the values."""
        language_equivalent: global___Type.MapType.LanguageEquivalent.ValueType
        """The language-specific type that this map type should be generated as."""
        def __init__(
            self,
            *,
            key_type: global___Type | None = ...,
            value_type: global___Type | None = ...,
            language_equivalent: global___Type.MapType.LanguageEquivalent.ValueType = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["key_type", b"key_type", "value_type", b"value_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key_type", b"key_type", "language_equivalent", b"language_equivalent", "value_type", b"value_type"]) -> None: ...

    SCALAR_TYPE_FIELD_NUMBER: builtins.int
    ENUM_TYPE_FIELD_NUMBER: builtins.int
    BYTES_TYPE_FIELD_NUMBER: builtins.int
    MESSAGE_TYPE_FIELD_NUMBER: builtins.int
    REPEATED_TYPE_FIELD_NUMBER: builtins.int
    MAP_TYPE_FIELD_NUMBER: builtins.int
    scalar_type: global___Type.ScalarType.ValueType
    """Protobuf scalar types."""
    @property
    def enum_type(self) -> global___Type.EnumType:
        """Protobuf enum types."""
    @property
    def bytes_type(self) -> global___Type.BytesType:
        """The bytes type"""
    @property
    def message_type(self) -> global___Type.MessageType:
        """Protobuf message types."""
    @property
    def repeated_type(self) -> global___Type.RepeatedType:
        """The repeated type."""
    @property
    def map_type(self) -> global___Type.MapType:
        """The map type."""
    def __init__(
        self,
        *,
        scalar_type: global___Type.ScalarType.ValueType = ...,
        enum_type: global___Type.EnumType | None = ...,
        bytes_type: global___Type.BytesType | None = ...,
        message_type: global___Type.MessageType | None = ...,
        repeated_type: global___Type.RepeatedType | None = ...,
        map_type: global___Type.MapType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bytes_type", b"bytes_type", "enum_type", b"enum_type", "map_type", b"map_type", "message_type", b"message_type", "repeated_type", b"repeated_type", "scalar_type", b"scalar_type", "type_kind", b"type_kind"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bytes_type", b"bytes_type", "enum_type", b"enum_type", "map_type", b"map_type", "message_type", b"message_type", "repeated_type", b"repeated_type", "scalar_type", b"scalar_type", "type_kind", b"type_kind"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type_kind", b"type_kind"]) -> typing_extensions.Literal["scalar_type", "enum_type", "bytes_type", "message_type", "repeated_type", "map_type"] | None: ...

global___Type = Type

@typing_extensions.final
class Expression(google.protobuf.message.Message):
    """An expression to be used, for instance, for parameter, variable and request
    initialization.
    On type inference:
    - When used for parameter or variable initialization, that is, when used in a
      Statement.Declaration, we have Statement.Declaration.Type.
    - When used for request initialization, we know the request type.
    - When used to initialize other elements, like client options, etc. we will
      know which types may be infer on a case by case basis as specified by each
      of these elements documentation.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _NullValue:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _NullValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Expression._NullValue.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        NULL_VALUE: Expression._NullValue.ValueType  # 0
        """Null value."""

    class NullValue(_NullValue, metaclass=_NullValueEnumTypeWrapper):
        """The null value. Might not be accepted by all types."""

    NULL_VALUE: Expression.NullValue.ValueType  # 0
    """Null value."""

    class _DefaultValue:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DefaultValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Expression._DefaultValue.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        DEFAULT_VALUE: Expression._DefaultValue.ValueType  # 0
        """Default value."""

    class DefaultValue(_DefaultValue, metaclass=_DefaultValueEnumTypeWrapper):
        """The default value.
        Note that when a value is used, the type is always known/inferred.
        Supported types are currently protobuf scalar types and protobuf message
        types so all types should have a default value.
        For protobuf message types, the default value should be the empty message.
        """

    DEFAULT_VALUE: Expression.DefaultValue.ValueType  # 0
    """Default value."""

    @typing_extensions.final
    class NameValue(google.protobuf.message.Message):
        """A variable or parameter name."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        PATH_FIELD_NUMBER: builtins.int
        name: builtins.str
        """The name of the variable or parameter name. Required."""
        @property
        def path(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """A path within name that refers to a nested value. Optional.
            Note that this path must be valid across all languages, so, the following
            rules apply.
            - A path in a NameValue is only allowed if name refers to a value of
              google.cloud.tools.snippetgen.configlanguage.v1.Type.MessageType, i.e.
              a protobuf message.
            - The path segments should be named as they appear on the proto
              definition and not as they are on any specific language.
            For instance, if the following message is defined:
            ```
            message SampleMessage  {
              int one_field = 0;
              SampleMessage nested_field = 1;
            }
            ```
            and a Declaration of
            - Declaration.type => SampleMessage and
            - Declaration.name => sample_value
            then posible NameValues that refer to the variable declared are:
            - NameValue.name => sample_value and NameValue.path => unset to reference
              the value of the sample_value variable, i.e. using the variable
              sample_value
            - NameValue.name => sample_value and NameValue.path => one_field to
              reference the value of the one_field value of the message instance
              stored in the sample_value variable, i.e. using the variable
              sample_value.one_field.
            - NameValue.sample_value and NameValue.path => nested_field, one_field to
              reference the one_field value of the nested_field value of the message
              instance stored in the sample_value variable, i.e. using the variable
              sample_value.nested_field.one_field.
            """
        def __init__(
            self,
            *,
            name: builtins.str = ...,
            path: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "path", b"path"]) -> None: ...

    @typing_extensions.final
    class BytesValue(google.protobuf.message.Message):
        """A bytes value. This represents initialization of objects from which
        arbitrary byte sequences may be ontained.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing_extensions.final
        class FileStream(google.protobuf.message.Message):
            """A language-specific file stream."""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            FILE_PATH_FIELD_NUMBER: builtins.int
            @property
            def file_path(self) -> global___Expression:
                """The path of the file to build the stream from.
                This expression should evaluate to a string value.
                """
            def __init__(
                self,
                *,
                file_path: global___Expression | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["file_path", b"file_path"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["file_path", b"file_path"]) -> None: ...

        BASE64_STRING_FIELD_NUMBER: builtins.int
        FILE_STREAM_FIELD_NUMBER: builtins.int
        @property
        def base64_string(self) -> global___Expression:
            """A Base64 encoded string.
            This expression should resolve to a string value.
            """
        @property
        def file_stream(self) -> global___Expression.BytesValue.FileStream:
            """A file stream."""
        def __init__(
            self,
            *,
            base64_string: global___Expression | None = ...,
            file_stream: global___Expression.BytesValue.FileStream | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["base64_string", b"base64_string", "file_stream", b"file_stream", "value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["base64_string", b"base64_string", "file_stream", b"file_stream", "value", b"value"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["value", b"value"]) -> typing_extensions.Literal["base64_string", "file_stream"] | None: ...

    @typing_extensions.final
    class ComplexValue(google.protobuf.message.Message):
        """A complex value. This represents initialization of complex objects, most
        likely of protobuf messages.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing_extensions.final
        class PropertiesEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: builtins.str
            @property
            def value(self) -> global___Expression: ...
            def __init__(
                self,
                *,
                key: builtins.str = ...,
                value: global___Expression | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

        PROPERTIES_FIELD_NUMBER: builtins.int
        @property
        def properties(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___Expression]:
            """This is a simple map from message property name to Expression.
            - All keys in the map should correspond to top level properties of the
              protobuf message.
            - Nested properties may be initialized thanks to the recursive nature of
              ComplexValue.
            - Each Expression in the map should resolve to the type of the property
              whose name is the associated key.
            """
        def __init__(
            self,
            *,
            properties: collections.abc.Mapping[builtins.str, global___Expression] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["properties", b"properties"]) -> None: ...

    @typing_extensions.final
    class RepeatedValue(google.protobuf.message.Message):
        """A list value. This represens initialization of collections, list, arrays
        and similar values.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        VALUES_FIELD_NUMBER: builtins.int
        @property
        def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            """The values that should be used to initialize a language-specific
            collection, list, array or similar.
            - The values should be used in the same order as they appear in values,
              regardless of whether the target collection type represents an ordered
              collection or not.
            - Each Expression should resolve to a type that is assignable to the type
              of the elements in the target collection.
            """
        def __init__(
            self,
            *,
            values: collections.abc.Iterable[global___Expression] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["values", b"values"]) -> None: ...

    @typing_extensions.final
    class MapValue(google.protobuf.message.Message):
        """A map value. This represents initialization of maps, dictionaries and
        similar values.
        Note that we cannot use a protobuf map for the definition of MapValue
        because protobuf map do not accept message types as the key type.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEYS_FIELD_NUMBER: builtins.int
        VALUES_FIELD_NUMBER: builtins.int
        @property
        def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            """The keys to use for initializing a language-specific map, dictionary or
            similar.
            - Each key Expression should resolve to a type that is assignable to
              the key type of the target map.
            """
        @property
        def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expression]:
            """The values to use for initializing a language-specific map, dictionary or
            similar.
            - Each value Expression should resolve to a type that is assignable to
              the value type of the target map.
            - Each value should be present in the same order as the corresponding key
              is in keys.
            """
        def __init__(
            self,
            *,
            keys: collections.abc.Iterable[global___Expression] | None = ...,
            values: collections.abc.Iterable[global___Expression] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["keys", b"keys", "values", b"values"]) -> None: ...

    @typing_extensions.final
    class ConditionalOperator(google.protobuf.message.Message):
        """A conditional value. This expression has one of two given values
        depending on the result of evaluating a given condition.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        CONDITION_FIELD_NUMBER: builtins.int
        ON_TRUE_FIELD_NUMBER: builtins.int
        ON_FALSE_FIELD_NUMBER: builtins.int
        @property
        def condition(self) -> global___Expression:
            """The condition to evaluate. Should resolve to a Boolean value."""
        @property
        def on_true(self) -> global___Expression:
            """The value of this expression if condition evaluates to true. on_true
            should resolve to a type that is assignable to the target type of this
            expression.
            """
        @property
        def on_false(self) -> global___Expression:
            """The value of this expression if condition evaluates to false. on_false
            should resolve to a type that is assignable to the target type of this
            expression.
            """
        def __init__(
            self,
            *,
            condition: global___Expression | None = ...,
            on_true: global___Expression | None = ...,
            on_false: global___Expression | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["condition", b"condition", "on_false", b"on_false", "on_true", b"on_true"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["condition", b"condition", "on_false", b"on_false", "on_true", b"on_true"]) -> None: ...

    NULL_VALUE_FIELD_NUMBER: builtins.int
    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    NAME_VALUE_FIELD_NUMBER: builtins.int
    NUMBER_VALUE_FIELD_NUMBER: builtins.int
    BOOLEAN_VALUE_FIELD_NUMBER: builtins.int
    STRING_VALUE_FIELD_NUMBER: builtins.int
    ENUM_VALUE_FIELD_NUMBER: builtins.int
    BYTES_VALUE_FIELD_NUMBER: builtins.int
    COMPLEX_VALUE_FIELD_NUMBER: builtins.int
    LIST_VALUE_FIELD_NUMBER: builtins.int
    MAP_VALUE_FIELD_NUMBER: builtins.int
    CONDITIONAL_VALUE_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    null_value: global___Expression.NullValue.ValueType
    """The null value. Might not be accepted by all types."""
    default_value: global___Expression.DefaultValue.ValueType
    """The default value.
    Note that when a value is used, type is always known/inferred. Supported
    types are currently protobuf scalar types and protobuf message types so
    all types should have a default value.
    """
    @property
    def name_value(self) -> global___Expression.NameValue:
        """A variable or parameter name, and possibly a path within."""
    number_value: builtins.float
    """A number literal."""
    boolean_value: builtins.bool
    """A Boolean literal."""
    string_value: builtins.str
    """A string literal."""
    enum_value: builtins.str
    """An enum value. The text is to be the enum value name as defined in
    protobuf. For instance, for a protobuf enum
    `enum SampleEnum { VALUE_0 = 0; VALUE_1 = 1; }`
    the accepted values here would be VALUE_0 and VALUE_1.
    """
    @property
    def bytes_value(self) -> global___Expression.BytesValue:
        """A bytes value. This represents initialization of objects from which
        arbitrary byte sequences may be obtained.
        """
    @property
    def complex_value(self) -> global___Expression.ComplexValue:
        """A complex value. This represents initialization of complex objects, most
        likely of protobuf messages.
        """
    @property
    def list_value(self) -> global___Expression.RepeatedValue:
        """A list value. This represents initialization of collections, list, arrays
        and similar values.
        """
    @property
    def map_value(self) -> global___Expression.MapValue:
        """A map value. This represents initialization of maps, dictionaries and
        similar values.
        """
    @property
    def conditional_value(self) -> global___Expression.ConditionalOperator:
        """A conditional value. This expression has one of two given values
        depending on the result of evaluating a given condition.
        """
    description: builtins.str
    """An optional description that will be included in the snippet alongside the
    value, likely as a code comment.
    """
    def __init__(
        self,
        *,
        null_value: global___Expression.NullValue.ValueType = ...,
        default_value: global___Expression.DefaultValue.ValueType = ...,
        name_value: global___Expression.NameValue | None = ...,
        number_value: builtins.float = ...,
        boolean_value: builtins.bool = ...,
        string_value: builtins.str = ...,
        enum_value: builtins.str = ...,
        bytes_value: global___Expression.BytesValue | None = ...,
        complex_value: global___Expression.ComplexValue | None = ...,
        list_value: global___Expression.RepeatedValue | None = ...,
        map_value: global___Expression.MapValue | None = ...,
        conditional_value: global___Expression.ConditionalOperator | None = ...,
        description: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["boolean_value", b"boolean_value", "bytes_value", b"bytes_value", "complex_value", b"complex_value", "conditional_value", b"conditional_value", "default_value", b"default_value", "enum_value", b"enum_value", "list_value", b"list_value", "map_value", b"map_value", "name_value", b"name_value", "null_value", b"null_value", "number_value", b"number_value", "string_value", b"string_value", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["boolean_value", b"boolean_value", "bytes_value", b"bytes_value", "complex_value", b"complex_value", "conditional_value", b"conditional_value", "default_value", b"default_value", "description", b"description", "enum_value", b"enum_value", "list_value", b"list_value", "map_value", b"map_value", "name_value", b"name_value", "null_value", b"null_value", "number_value", b"number_value", "string_value", b"string_value", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["value", b"value"]) -> typing_extensions.Literal["null_value", "default_value", "name_value", "number_value", "boolean_value", "string_value", "enum_value", "bytes_value", "complex_value", "list_value", "map_value", "conditional_value"] | None: ...

global___Expression = Expression
